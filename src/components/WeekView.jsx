'use client'

// Batch 5 - Cleaner Mobile Layout
import { useState, useMemo, useEffect, useRef, useCallback } from 'react'
import { useUser } from '@/context/UserContext'
import { Button } from '@/components/ui/button'
import {
  getDatesFromStart,
  formatDateRange,
  formatDayTab,
  formatDayHeader,
  isSameDay,
  toISODate
} from '@/lib/dates'
import { generateDayMeals, getAlternativesForSlot } from '@/lib/mealPlanner'
import {
  generateSmartWeek,
  generateSmartWeekForHousehold,
  calculateMemberPortion,
  calculateMemberDayTotals,
  formatPortion
} from '@/lib/smartPlanner'
import { generateShoppingList, saveShoppingList, loadShoppingList, generateMealPlanHash, clearShoppingList } from '@/lib/shoppingList'
import { RefreshCw, X, Clock, ShoppingCart, Check, AlertCircle, Sparkles, Loader2, Printer, ListPlus, Trash2 } from 'lucide-react'
import { toAustralianName, formatQuantity } from '@/lib/ingredientFormat'
import RecipeOverlay from '@/components/RecipeOverlay'

// Helper to sanitize text (remove IP addresses and URLs from any string)
const sanitizeText = (text) => {
  if (!text) return ''
  return text
    // Remove IP addresses (e.g., 192.168.20.10)
    .replace(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, '')
    // Remove URLs
    .replace(/https?:\/\/[^\s]+/g, '')
    // Remove localhost references
    .replace(/localhost:\d+/gi, '')
    // Clean up any double spaces
    .replace(/\s{2,}/g, ' ')
    .trim()
}

// Alias for backward compatibility
const sanitizeDescription = sanitizeText

// Meal slots for the day (16:8 fasting window: 12:00-20:00)
const MEAL_SLOTS = [
  { id: 'lunch', label: 'Lunch', icon: 'ðŸ¥—', time: '12:00' },
  { id: 'snack_afternoon', label: 'Afternoon Snack', icon: 'ðŸŽ', time: '15:00' },
  { id: 'dinner', label: 'Dinner', icon: 'ðŸ½ï¸', time: '18:00' },
  { id: 'snack_evening', label: 'Evening Snack', icon: 'ðŸ«', time: '19:30' },
]

// Number of days to show in slider
const VISIBLE_DAYS = 7

export default function WeekView() {
  const {
    user,
    targets,
    household,
    members,
    activeMember,
    setActiveMember,
    isHouseholdMode,
    householdDietaryRestrictions
  } = useUser()

  // Today is always the starting point
  const today = useMemo(() => {
    const d = new Date()
    d.setHours(0, 0, 0, 0)
    return d
  }, [])

  // Generate dates starting from today
  const allDates = useMemo(() => getDatesFromStart(today, VISIBLE_DAYS), [today])

  // LocalStorage key for this user's meals
  const storageKey = user ? `meal-plan-${user.id}` : 'meal-plan-guest'

  // Refs for scrolling and auto-generation tracking
  const scrollContainerRef = useRef(null)
  const mainContentRef = useRef(null)
  const hasAutoGenerated = useRef(false)

  // State - initialize with defaults, hydrate in useEffect to avoid SSR mismatch
  const [selectedDate, setSelectedDateState] = useState(today)

  // Wrapper to also dispatch event when date changes and scroll to top
  const setSelectedDate = (date) => {
    setSelectedDateState(date)
    // Notify sidebar of date change
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('planner-date-changed', {
        detail: { date: toISODate(date) }
      }))
    }
    // Scroll main content to top when changing days
    if (mainContentRef.current) {
      mainContentRef.current.scrollTo({ top: 0, behavior: 'smooth' })
    }
  }
  const [meals, setMeals] = useState({})
  const [isHydrated, setIsHydrated] = useState(false)
  const [isInitialLoading, setIsInitialLoading] = useState(true) // For initial auto-generation loading state

  // Hydrate from localStorage after mount (avoids SSR mismatch)
  useEffect(() => {
    setSelectedDate(today)

    // Load meals from localStorage
    if (storageKey) {
      try {
        const saved = localStorage.getItem(storageKey)
        if (saved) {
          setMeals(JSON.parse(saved))
        }
      } catch (e) {
        console.error('Failed to load meals from localStorage:', e)
      }
    }

    setIsHydrated(true)
  }, [])
  
  const [swappingSlot, setSwappingSlot] = useState(null)
  const [alternativeSearch, setAlternativeSearch] = useState('')
  const [alternativeCategory, setAlternativeCategory] = useState('all')
  const [justCommitted, setJustCommitted] = useState(false)
  const [committedHash, setCommittedHash] = useState(null)
  const [isGenerating, setIsGenerating] = useState(false)
  const [generationError, setGenerationError] = useState(null)
  const [showGenerateModal, setShowGenerateModal] = useState(false)
  const [excludedMeals, setExcludedMeals] = useState([]) // Array of "dateKey-slotId" strings
  const [showFirstDayPulse, setShowFirstDayPulse] = useState(false)

  // Listen for onboarding completion to show pulse animation
  useEffect(() => {
    const handleOnboardingComplete = () => {
      setShowFirstDayPulse(true)
      // Stop pulsing after 3 seconds
      setTimeout(() => setShowFirstDayPulse(false), 3000)
    }
    window.addEventListener('onboarding-complete', handleOnboardingComplete)
    return () => window.removeEventListener('onboarding-complete', handleOnboardingComplete)
  }, [])

  // Load committed hash on mount
  useEffect(() => {
    if (user) {
      const saved = loadShoppingList(user.id)
      if (saved?.mealPlanHash) {
        setCommittedHash(saved.mealPlanHash)
      }
    }
  }, [user?.id])
  
  // Save to localStorage whenever meals change
  const saveMeals = (newMeals) => {
    setMeals(newMeals)
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem(storageKey, JSON.stringify(newMeals))
      } catch (e) {
        console.error('Failed to save meals to localStorage:', e)
      }
    }
  }
  
  // Reload from localStorage when user changes
  useEffect(() => {
    if (isHydrated && user) {
      try {
        const saved = localStorage.getItem(storageKey)
        setMeals(saved ? JSON.parse(saved) : {})
        // Load excluded meals
        const excludedKey = `excluded-meals-${user.id}`
        const savedExcluded = localStorage.getItem(excludedKey)
        setExcludedMeals(savedExcluded ? JSON.parse(savedExcluded) : [])
      } catch (e) {
        console.error('Failed to reload meals:', e)
      }
    }
  }, [user?.id, isHydrated, storageKey])

  // Toggle meal exclusion from shopping list
  const toggleMealExclusion = useCallback((dateKey, slotId) => {
    const key = `${dateKey}-${slotId}`
    setExcludedMeals(prev => {
      const newExcluded = prev.includes(key)
        ? prev.filter(k => k !== key)
        : [...prev, key]
      // Persist to localStorage
      if (user) {
        try {
          localStorage.setItem(`excluded-meals-${user.id}`, JSON.stringify(newExcluded))
        } catch (e) {
          console.error('Failed to save excluded meals:', e)
        }
      }
      return newExcluded
    })
  }, [user])

  // Check if a meal is excluded
  const isMealExcluded = useCallback((dateKey, slotId) => {
    return excludedMeals.includes(`${dateKey}-${slotId}`)
  }, [excludedMeals])
  
  // Get meals for selected day
  const selectedDateKey = toISODate(selectedDate)
  const dayMeals = meals[selectedDateKey] || {}
  
  // Get all used recipe IDs (for variety)
  const usedRecipeIds = useMemo(() => {
    const ids = []
    Object.values(meals).forEach(dayMeals => {
      Object.values(dayMeals).forEach(recipe => {
        if (recipe?.id && !ids.includes(recipe.id)) {
          ids.push(recipe.id)
        }
      })
    })
    return ids
  }, [meals])
  
  // Calculate day totals
  const dayTotals = useMemo(() => {
    if (isHouseholdMode && activeMember) {
      return calculateMemberDayTotals(dayMeals, activeMember)
    }

    const totals = { calories: 0, protein: 0, fat: 0, carbs: 0 }
    Object.values(dayMeals).forEach(recipe => {
      if (recipe?.per_serve) {
        totals.calories += recipe.per_serve.calories || 0
        totals.protein += recipe.per_serve.protein_g || 0
        totals.fat += recipe.per_serve.fat_g || 0
        totals.carbs += recipe.per_serve.carbs_g || 0
      }
    })
    return totals
  }, [dayMeals, isHouseholdMode, activeMember])

  // Check if current week has any meals
  const currentWeekHasMeals = useMemo(() => {
    return allDates.some(date => {
      const dateKey = toISODate(date)
      return Object.keys(meals[dateKey] || {}).length > 0
    })
  }, [allDates, meals])

  // Count total meals in current week
  const totalWeekMeals = useMemo(() => {
    let count = 0
    allDates.forEach(date => {
      const dateKey = toISODate(date)
      count += Object.keys(meals[dateKey] || {}).length
    })
    return count
  }, [allDates, meals])

  // Generate meals using AI for the week (auto or manual refresh)
  const handleGenerateWeek = useCallback(async (isAutoGenerate = false) => {
    if (!user || !targets) {
      if (!isAutoGenerate) {
        setGenerationError('Please set up your profile first')
      }
      setIsInitialLoading(false)
      return
    }

    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result

      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        })
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply generated meals to all 7 days
      const newMeals = { ...meals }
      const planKeys = Object.keys(result.weekPlan)
      allDates.forEach((date, index) => {
        const dateKey = toISODate(date)
        // Use modulo in case we have more days than generated
        const planIndex = index % planKeys.length
        if (result.weekPlan[planIndex]?.meals) {
          newMeals[dateKey] = result.weekPlan[planIndex].meals
        }
      })

      saveMeals(newMeals)
      setSwappingSlot(null)

      console.log('Smart generation cost:', result.usage?.estimated_cost)

    } catch (error) {
      console.error('Smart generation failed:', error)
      if (!isAutoGenerate) {
        setGenerationError(error.message || 'Failed to generate meals')
      }
    } finally {
      setIsGenerating(false)
      setIsInitialLoading(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, allDates, saveMeals])

  // Mark initial loading complete once hydrated
  useEffect(() => {
    if (isHydrated) {
      setIsInitialLoading(false)
    }
  }, [isHydrated])

  // Get days that need meals (completely empty days)
  const emptyDays = useMemo(() => {
    return allDates.filter(date => {
      const dateKey = toISODate(date)
      return Object.keys(meals[dateKey] || {}).length === 0
    })
  }, [allDates, meals])

  // Get empty slots for the selected day
  const emptySlotsForDay = useMemo(() => {
    return MEAL_SLOTS.filter(slot => !dayMeals[slot.id]).map(slot => slot.id)
  }, [dayMeals])

  // Multi-select mode for clearing days
  const [clearSelectionMode, setClearSelectionMode] = useState(false)
  const [selectedForClearing, setSelectedForClearing] = useState([])
  const [alsoClearShoppingList, setAlsoClearShoppingList] = useState(false)
  const longPressTimer = useRef(null)

  // Enter selection mode with a day
  const enterClearSelectionMode = useCallback((dateKey) => {
    setClearSelectionMode(true)
    setSelectedForClearing([dateKey])
  }, [])

  // Toggle a day in the selection
  const toggleDayForClearing = useCallback((dateKey) => {
    if (!clearSelectionMode) return
    setSelectedForClearing(prev =>
      prev.includes(dateKey)
        ? prev.filter(d => d !== dateKey)
        : [...prev, dateKey]
    )
  }, [clearSelectionMode])

  // Exit selection mode
  const exitClearSelectionMode = useCallback(() => {
    setClearSelectionMode(false)
    setSelectedForClearing([])
    setAlsoClearShoppingList(false)
  }, [])

  // Clear all selected days
  const handleClearSelectedDays = useCallback(() => {
    if (selectedForClearing.length === 0) return
    const newMeals = { ...meals }
    selectedForClearing.forEach(dateKey => {
      delete newMeals[dateKey]
    })
    saveMeals(newMeals)

    // Also clear shopping list if checkbox was checked
    if (alsoClearShoppingList && user) {
      clearShoppingList(user.id)
      setCommittedHash(null)
    }

    exitClearSelectionMode()
  }, [meals, selectedForClearing, saveMeals, exitClearSelectionMode, alsoClearShoppingList, user])

  // Count total meals in selected days for clearing
  const selectedClearMealCount = useMemo(() => {
    let count = 0
    selectedForClearing.forEach(dateKey => {
      count += Object.keys(meals[dateKey] || {}).length
    })
    return count
  }, [selectedForClearing, meals])

  // Multi-select mode for generating days (mirror of clear mode)
  const [generateSelectionMode, setGenerateSelectionMode] = useState(false)
  const [selectedForGenerating, setSelectedForGenerating] = useState([])

  // Enter generate selection mode with a day
  const enterGenerateSelectionMode = useCallback((dateKey) => {
    setGenerateSelectionMode(true)
    setSelectedForGenerating([dateKey])
  }, [])

  // Toggle a day in the generate selection
  const toggleDayForGenerating = useCallback((dateKey) => {
    if (!generateSelectionMode) return
    setSelectedForGenerating(prev =>
      prev.includes(dateKey)
        ? prev.filter(d => d !== dateKey)
        : [...prev, dateKey]
    )
  }, [generateSelectionMode])

  // Exit generate selection mode
  const exitGenerateSelectionMode = useCallback(() => {
    setGenerateSelectionMode(false)
    setSelectedForGenerating([])
  }, [])

  // Generate meals for selected days
  const handleGenerateSelectedDays = useCallback(async () => {
    if (selectedForGenerating.length === 0) return
    if (!user || !targets) {
      setGenerationError('Please set up your profile first')
      return
    }

    setGenerateSelectionMode(false)
    setIsGenerating(true)
    setGenerationError(null)

    try {
      console.log('Generating for selected days:', selectedForGenerating)

      let result
      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        })
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      console.log('Generation result:', result)

      // Apply generated meals only to the selected days
      if (result?.weekPlan) {
        const newMeals = { ...meals }
        const planKeys = Object.keys(result.weekPlan)

        // Map each selected date to a plan day (cycling if needed)
        selectedForGenerating.forEach((dateKey, index) => {
          const planIndex = index % planKeys.length
          if (result.weekPlan[planIndex]?.meals) {
            newMeals[dateKey] = result.weekPlan[planIndex].meals
            console.log(`Assigned plan[${planIndex}] to ${dateKey}:`, result.weekPlan[planIndex].meals)
          }
        })

        saveMeals(newMeals)
        console.log('Meals saved successfully')
      }
    } catch (err) {
      console.error('Generation failed:', err)
      setGenerationError(err.message || 'Generation failed')
    } finally {
      setIsGenerating(false)
      setSelectedForGenerating([])
    }
  }, [selectedForGenerating, user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, saveMeals])

  // Generate meals for a single day (only fills empty slots, preserves existing meals)
  const handleGenerateDay = useCallback(async () => {
    if (!user || !targets) {
      setGenerationError('Please set up your profile first')
      return
    }

    // Check if there are any empty slots to fill
    if (emptySlotsForDay.length === 0) {
      setShowGenerateModal(false)
      return
    }

    setShowGenerateModal(false)
    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result
      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        }, user?.id)
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply only to empty slots on selected day (preserve existing meals)
      const newMeals = { ...meals }
      const existingDayMeals = newMeals[selectedDateKey] || {}
      const generatedMeals = result.weekPlan[0]?.meals || {}

      // Merge: keep existing meals, fill only empty slots with generated ones
      const mergedDayMeals = { ...existingDayMeals }
      emptySlotsForDay.forEach(slotId => {
        if (generatedMeals[slotId]) {
          mergedDayMeals[slotId] = generatedMeals[slotId]
        }
      })

      newMeals[selectedDateKey] = mergedDayMeals
      saveMeals(newMeals)

    } catch (error) {
      console.error('Day generation failed:', error)
      setGenerationError(error.message || 'Failed to generate meals')
    } finally {
      setIsGenerating(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, selectedDateKey, emptySlotsForDay, saveMeals])

  // Generate meals only for empty days
  const handleFillEmptyDays = useCallback(async () => {
    if (!user || !targets) {
      setGenerationError('Please set up your profile first')
      return
    }

    if (emptyDays.length === 0) {
      setShowGenerateModal(false)
      return
    }

    setShowGenerateModal(false)
    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result
      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        }, user?.id)
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply only to empty days
      const newMeals = { ...meals }
      const planKeys = Object.keys(result.weekPlan)
      emptyDays.forEach((date, index) => {
        const dateKey = toISODate(date)
        const planIndex = index % planKeys.length
        if (result.weekPlan[planIndex]?.meals) {
          newMeals[dateKey] = result.weekPlan[planIndex].meals
        }
      })
      saveMeals(newMeals)

    } catch (error) {
      console.error('Fill empty days failed:', error)
      setGenerationError(error.message || 'Failed to generate meals')
    } finally {
      setIsGenerating(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, emptyDays, saveMeals])
  
  // Swap a meal in a slot
  const handleSwapMeal = (slotId, newRecipe) => {
    saveMeals({
      ...meals,
      [selectedDateKey]: {
        ...meals[selectedDateKey],
        [slotId]: newRecipe
      }
    })
    setSwappingSlot(null)
  }
  
  // Clear a slot
  const handleClearSlot = (slotId) => {
    const newDayMeals = { ...meals[selectedDateKey] }
    delete newDayMeals[slotId]
    saveMeals({
      ...meals,
      [selectedDateKey]: newDayMeals
    })
    setSwappingSlot(null)
  }
  
  // Print day's recipes
  const handlePrintDayRecipes = () => {
    const dateLabel = formatDayHeader(selectedDate)
    
    // Build print content
    let html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>Meal Plan - ${dateLabel}</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
          h1 { font-size: 24px; margin-bottom: 8px; }
          .subtitle { color: #666; margin-bottom: 24px; }
          .recipe { margin-bottom: 32px; page-break-inside: avoid; }
          .recipe-header { border-bottom: 2px solid #333; padding-bottom: 8px; margin-bottom: 12px; }
          .recipe-title { font-size: 18px; font-weight: 600; margin: 0; }
          .recipe-meta { font-size: 12px; color: #666; margin-top: 4px; }
          .section-title { font-size: 14px; font-weight: 600; margin: 16px 0 8px 0; }
          .ingredients { list-style: none; padding: 0; }
          .ingredients li { padding: 4px 0; display: flex; gap: 12px; }
          .ingredients .amount { color: #666; min-width: 60px; }
          .instructions { padding-left: 20px; }
          .instructions li { padding: 4px 0; }
          .portions { font-size: 12px; color: #666; margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; }
          .batch-note { font-size: 12px; color: #666; font-style: italic; margin-top: 8px; }
          .close-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            background: #333;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          }
          .close-btn:hover {
            background: #555;
          }
          @media print {
            .recipe { page-break-inside: avoid; }
            .close-btn { display: none; }
          }
        </style>
      </head>
      <body>
        <button class="close-btn" onclick="window.close()">âœ• Close</button>
        <h1>${dateLabel}</h1>
        <div class="subtitle">Meal Plan${isHouseholdMode && members.length > 0 ? ` for ${members.map(m => m.name).join(' & ')}` : ''}</div>
    `
    
    MEAL_SLOTS.forEach(slot => {
      const recipe = dayMeals[slot.id]
      if (!recipe) return
      
      // Calculate household portions
      let householdTotal = 1
      let portionBreakdown = []
      
      if (isHouseholdMode && members && members.length > 0) {
        const portions = members.map(member => {
          const portion = calculateMemberPortion(member, recipe, slot.id)
          return { name: member.name, portion }
        })
        householdTotal = portions.reduce((sum, p) => sum + p.portion, 0)
        portionBreakdown = portions.map(p => ({
          name: p.name,
          percentage: Math.round((p.portion / householdTotal) * 100)
        }))
      }
      
      html += `
        <div class="recipe">
          <div class="recipe-header">
            <h2 class="recipe-title">${slot.icon} ${slot.label}: ${recipe.name}</h2>
            <div class="recipe-meta">${slot.time} Â· ${recipe.total_time_mins || '?'} min Â· ${recipe.per_serve?.calories || '?'} cal</div>
          </div>
          
          <div class="section-title">Ingredients${householdTotal > 1 ? ` (serves ${members.length})` : ''}</div>
          <ul class="ingredients">
      `
      
      recipe.ingredients?.forEach(ing => {
        // Divide by base_servings first (recipe amounts are for base_servings), then multiply by household needs
        const baseServings = recipe.base_servings || 1
        const perServeGrams = (ing.grams || 0) / baseServings
        const scaledGrams = householdTotal > 1 ? perServeGrams * householdTotal : perServeGrams
        const auName = toAustralianName(ing.name)
        const qty = formatQuantity(scaledGrams, ing.name)
        html += `<li><span class="amount">${qty}</span><span>${auName}${ing.notes ? ` (${ing.notes})` : ''}</span></li>`
      })
      
      html += `</ul>`
      
      if (portionBreakdown.length > 0) {
        html += `<div class="portions"><strong>Portions:</strong> ${portionBreakdown.map(p => `${p.name}: ${p.percentage}%`).join(' Â· ')}</div>`
      }
      
      html += `<div class="section-title">Method</div><ol class="instructions">`
      
      recipe.instructions?.forEach(step => {
        html += `<li>${step}</li>`
      })
      
      html += `</ol>`
      
      if (recipe.batch_notes) {
        html += `<div class="batch-note">ðŸ’¡ ${recipe.batch_notes}</div>`
      }
      
      html += `</div>`
    })
    
    html += `</body></html>`
    
    // Open print window
    const printWindow = window.open('', '_blank')
    if (printWindow) {
      printWindow.document.write(html)
      printWindow.document.close()
      // Auto-trigger print dialog after brief delay
      setTimeout(() => {
        printWindow.print()
      }, 300)
      // Note: Window stays open with close button - user can close manually
      // Safari/iOS often blocks auto-close, so we provide visible button instead
    }
  }
  
  // Get alternatives for current swap
  // Only exclude recipes used on the SAME day (not entire week - too restrictive for swapping)
  const alternatives = useMemo(() => {
    if (!swappingSlot) return []
    const currentRecipe = dayMeals[swappingSlot]
    const sameDayRecipeIds = Object.values(dayMeals)
      .filter(r => r?.id)
      .map(r => r.id)
    return getAlternativesForSlot(
      swappingSlot, 
      currentRecipe?.id, 
      sameDayRecipeIds
    )
  }, [swappingSlot, dayMeals])
  
  // Filter alternatives by search and category
  const filteredAlternatives = useMemo(() => {
    let filtered = alternatives
    
    // Text search
    if (alternativeSearch.trim()) {
      const search = alternativeSearch.toLowerCase()
      filtered = filtered.filter(r => 
        r.name.toLowerCase().includes(search) ||
        r.description?.toLowerCase().includes(search)
      )
    }
    
    // Category filter
    if (alternativeCategory !== 'all') {
      filtered = filtered.filter(r => r.category === alternativeCategory)
    }
    
    return filtered
  }, [alternatives, alternativeSearch, alternativeCategory])
  
  // Get unique categories from alternatives
  const availableCategories = useMemo(() => {
    const cats = new Set(alternatives.map(r => r.category).filter(Boolean))
    return ['all', ...Array.from(cats).sort()]
  }, [alternatives])
  
  // Reset filters when slot changes
  useEffect(() => {
    setAlternativeSearch('')
    setAlternativeCategory('all')
  }, [swappingSlot])

  // Get all date keys for current week
  const weekDateKeys = useMemo(() => {
    return allDates.map(d => toISODate(d))
  }, [allDates])

  // Calculate current meal plan hash (for current week)
  const currentHash = useMemo(() => {
    return generateMealPlanHash(meals, weekDateKeys)
  }, [meals, weekDateKeys])

  // Check if shopping list is stale
  const isListStale = committedHash && currentHash !== committedHash

  // Get week date range for display
  const weekDateRange = useMemo(() => {
    if (allDates.length === 0) return null
    return { first: allDates[0], last: allDates[allDates.length - 1] }
  }, [allDates])

  // Commit to shopping list (for current week)
  const handleCommitToShoppingList = () => {
    if (!user) return
    if (totalWeekMeals === 0) return

    const shoppingList = isHouseholdMode && members.length > 0
      ? generateShoppingList(meals, weekDateKeys, members)
      : generateShoppingList(meals, weekDateKeys, 1)

    const weekLabel = weekDateRange
      ? formatDateRange(weekDateRange.first, weekDateRange.last)
      : 'This week'
    const hash = generateMealPlanHash(meals, weekDateKeys)

    saveShoppingList(user.id, shoppingList, weekLabel, hash)
    setCommittedHash(hash)

    setJustCommitted(true)
    setTimeout(() => setJustCommitted(false), 2000)
  }

  // Format selected date for display - e.g., "Monday 8 December"
  const formattedSelectedDate = useMemo(() => {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    return `${days[selectedDate.getDay()]} ${selectedDate.getDate()} ${months[selectedDate.getMonth()]}`
  }, [selectedDate])

  // Show loading state during initial auto-generation
  if (isInitialLoading && isGenerating) {
    return (
      <div className="flex-1 flex flex-col">
        {/* Mobile Header - Green bar */}
        <div className="md:hidden bg-primary text-primary-foreground px-4 py-3 safe-area-top">
          <h1 className="text-center font-semibold">Meal Planner</h1>
        </div>

        {/* Desktop Header */}
        <div className="hidden md:block p-6 pb-0">
          <h1 className="text-2xl font-bold">Meal Planner</h1>
          <p className="text-sm text-muted-foreground">
            {weekDateRange ? formatDateRange(weekDateRange.first, weekDateRange.last) : 'This week'}
          </p>
        </div>

        {/* Loading state */}
        <div className="flex-1 flex flex-col items-center justify-center py-16">
          <div className="relative">
            <Loader2 className="h-12 w-12 animate-spin text-primary" />
            <Sparkles className="h-5 w-5 text-primary absolute -top-1 -right-1" />
          </div>
          <p className="text-lg font-medium mt-4">Planning your week...</p>
          <p className="text-sm text-muted-foreground mt-1">
            Creating meals based on your targets
          </p>
        </div>

        {/* Skeleton meal cards */}
        <div className="space-y-3 px-4 pb-4">
          {MEAL_SLOTS.map((slot) => (
            <div key={slot.id} className="border rounded-xl p-4 animate-pulse">
              <div className="flex items-center gap-2 mb-2">
                <div className="h-4 w-4 bg-muted rounded" />
                <div className="h-4 w-20 bg-muted rounded" />
              </div>
              <div className="h-5 w-48 bg-muted rounded mb-2" />
              <div className="h-4 w-full bg-muted rounded" />
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <>
      {/* ===== GENERATE MODAL ===== */}
      {showGenerateModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
          <div className="bg-card rounded-xl p-6 max-w-sm w-full shadow-xl">
            <div className="flex items-center gap-2 mb-4">
              <Sparkles className="h-5 w-5 text-primary" />
              <h2 className="text-lg font-semibold">Generate Meals</h2>
            </div>

            <div className="space-y-3">
              <Button
                onClick={handleGenerateDay}
                disabled={isGenerating || emptySlotsForDay.length === 0}
                className="w-full justify-start h-auto py-3 flex-col items-start"
              >
                <div className="flex items-center w-full">
                  {isGenerating ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-3" />
                  ) : (
                    <Sparkles className="h-4 w-4 mr-3" />
                  )}
                  <span>Fill Today's Empty Slots</span>
                  {emptySlotsForDay.length > 0 && (
                    <span className="ml-auto text-xs opacity-80">
                      {emptySlotsForDay.length} slot{emptySlotsForDay.length !== 1 ? 's' : ''}
                    </span>
                  )}
                </div>
                {emptySlotsForDay.length === 0 ? (
                  <span className="text-xs opacity-70 mt-1 ml-7">
                    All slots filled for today
                  </span>
                ) : (
                  <span className="text-xs opacity-70 mt-1 ml-7">
                    Keeps existing meals, fills gaps
                  </span>
                )}
              </Button>

              <Button
                onClick={handleFillEmptyDays}
                disabled={isGenerating || emptyDays.length === 0}
                variant="outline"
                className="w-full justify-start h-auto py-3 flex-col items-start"
              >
                <div className="flex items-center w-full">
                  {isGenerating ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-3" />
                  ) : (
                    <Sparkles className="h-4 w-4 mr-3" />
                  )}
                  <span>Fill Empty Days</span>
                  {emptyDays.length > 0 && (
                    <span className="ml-auto text-xs text-muted-foreground">
                      {emptyDays.length} day{emptyDays.length !== 1 ? 's' : ''}
                    </span>
                  )}
                </div>
                <span className="text-xs text-muted-foreground mt-1 ml-7">
                  Keeps your existing meals, fills the gaps
                </span>
              </Button>

              <Button
                variant="ghost"
                onClick={() => setShowGenerateModal(false)}
                disabled={isGenerating}
                className="w-full"
              >
                Cancel
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* ===== MOBILE LAYOUT ===== */}
      <div
        className="md:hidden flex flex-col h-full overflow-hidden"
        style={{ overscrollBehavior: 'none' }}
      >
        {/* 1. HEADER BAR - Fixed at top, transforms when in selection mode */}
        <div className={`safe-area-top flex-shrink-0 transition-colors ${
          clearSelectionMode
            ? 'bg-orange-500 text-white'
            : generateSelectionMode
              ? 'bg-primary text-white'
              : 'bg-primary text-primary-foreground'
        }`}>
          <div className="flex items-center justify-between h-11 px-4">
            {clearSelectionMode ? (
              <>
                {/* Clear mode header */}
                <div className="flex items-center gap-2">
                  <Trash2 className="h-5 w-5" />
                  <span className="font-medium text-sm">Select days to clear</span>
                </div>
                <button
                  onClick={exitClearSelectionMode}
                  className="px-3 py-1 text-sm font-medium rounded-full bg-white/20 hover:bg-white/30 active:bg-white/40"
                >
                  Cancel
                </button>
              </>
            ) : generateSelectionMode ? (
              <>
                {/* Generate mode header */}
                <div className="flex items-center gap-2">
                  <Sparkles className="h-5 w-5" />
                  <span className="font-medium text-sm">Select days to generate</span>
                </div>
                <button
                  onClick={exitGenerateSelectionMode}
                  className="px-3 py-1 text-sm font-medium rounded-full bg-white/20 hover:bg-white/30 active:bg-white/40"
                >
                  Cancel
                </button>
              </>
            ) : (
              <>
                {/* Normal header */}
                {/* Left: Empty spacer for balance */}
                <div className="w-8 h-8" />
                {/* Center: Title */}
                <h1 className="font-semibold text-base">Meal Planner</h1>
                {/* Right: Print icon */}
                <button
                  onClick={handlePrintDayRecipes}
                  disabled={Object.keys(dayMeals).length === 0}
                  className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/10 active:bg-white/20 disabled:opacity-50"
                >
                  <Printer className="h-5 w-5" />
                </button>
              </>
            )}
          </div>

          {/* 2. DAY STRIP - Below header, horizontally scrollable - NEVER moves */}
          <div className={`border-b px-2 py-1.5 transition-colors ${
            clearSelectionMode
              ? 'bg-orange-50'
              : generateSelectionMode
                ? 'bg-primary/5'
                : 'bg-card'
          }`}>
            <div
              ref={scrollContainerRef}
              className="flex gap-1 overflow-x-auto snap-x snap-mandatory scroll-smooth"
              style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
            >
              {allDates.map((date) => {
                const dateKey = toISODate(date)
                const isViewing = isSameDay(date, selectedDate)
                const isToday = isSameDay(date, today)
                const dayMealCount = Object.keys(meals[dateKey] || {}).length
                const dayOfWeek = date.getDay()
                const dayAbbrev = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek]
                const isSelectedForClearing = selectedForClearing.includes(dateKey)
                const isSelectedForGenerating = selectedForGenerating.includes(dateKey)
                const hasMeals = dayMealCount > 0
                const isEmpty = !hasMeals

                // Handle touch events for long press (350ms to avoid iOS text selection)
                const handleTouchStart = () => {
                  // Don't start new long-press if already in a selection mode
                  if (clearSelectionMode || generateSelectionMode) return

                  longPressTimer.current = setTimeout(() => {
                    // Haptic feedback
                    if (navigator.vibrate) navigator.vibrate(50)
                    // Enter appropriate mode based on whether day has meals
                    if (hasMeals) {
                      enterClearSelectionMode(dateKey)
                    } else {
                      enterGenerateSelectionMode(dateKey)
                    }
                  }, 350)
                }

                const handleTouchEnd = () => {
                  if (longPressTimer.current) {
                    clearTimeout(longPressTimer.current)
                    longPressTimer.current = null
                  }
                }

                const handleClick = () => {
                  if (clearSelectionMode) {
                    // In clear mode, only toggle days with meals
                    if (hasMeals) {
                      toggleDayForClearing(dateKey)
                    }
                  } else if (generateSelectionMode) {
                    // In generate mode, only toggle empty days
                    if (isEmpty) {
                      toggleDayForGenerating(dateKey)
                    }
                  } else {
                    setSelectedDate(date)
                    setSwappingSlot(null)
                  }
                }

                // Determine button styling based on mode
                const getButtonStyle = () => {
                  if (clearSelectionMode) {
                    if (isSelectedForClearing) {
                      return 'bg-orange-500 text-white border-2 border-orange-600 shadow-md'
                    } else if (hasMeals) {
                      return 'bg-white border-2 border-orange-200 text-foreground'
                    } else {
                      return 'bg-muted/30 border border-transparent text-muted-foreground/50'
                    }
                  } else if (generateSelectionMode) {
                    if (isSelectedForGenerating) {
                      return 'bg-primary text-white border-2 border-primary shadow-md'
                    } else if (isEmpty) {
                      return 'bg-white border-2 border-primary/30 text-foreground'
                    } else {
                      return 'bg-muted/30 border border-transparent text-muted-foreground/50'
                    }
                  } else {
                    if (isViewing) {
                      return 'bg-primary text-primary-foreground shadow-md'
                    } else {
                      return 'bg-white border border-border text-foreground'
                    }
                  }
                }

                // Determine day abbrev text color
                const getDayAbbrevStyle = () => {
                  if (clearSelectionMode) {
                    if (isSelectedForClearing) return ''
                    if (hasMeals) return 'text-orange-600'
                    return 'text-muted-foreground/50'
                  } else if (generateSelectionMode) {
                    if (isSelectedForGenerating) return ''
                    if (isEmpty) return 'text-primary'
                    return 'text-muted-foreground/50'
                  } else {
                    return isViewing ? '' : 'text-muted-foreground'
                  }
                }

                // Determine meal dot color
                const getMealDotStyle = () => {
                  if (clearSelectionMode) {
                    return isSelectedForClearing ? 'bg-white/80' : 'bg-orange-400'
                  } else if (generateSelectionMode) {
                    return 'bg-muted-foreground/30'
                  } else {
                    return isViewing ? 'bg-primary-foreground/80' : 'bg-primary'
                  }
                }

                // Check if this is the first day and should pulse
                const shouldPulse = isToday && showFirstDayPulse && !clearSelectionMode && !generateSelectionMode

                return (
                  <button
                    key={dateKey}
                    onClick={handleClick}
                    onTouchStart={handleTouchStart}
                    onTouchEnd={handleTouchEnd}
                    onTouchCancel={handleTouchEnd}
                    onMouseDown={handleTouchStart}
                    onMouseUp={handleTouchEnd}
                    onMouseLeave={handleTouchEnd}
                    style={{ WebkitUserSelect: 'none', userSelect: 'none' }}
                    className={`relative flex-shrink-0 w-[calc((100%-20px)/5)] min-w-[50px] rounded-lg py-1 px-1 text-center snap-start transition-all select-none ${getButtonStyle()} ${shouldPulse ? 'animate-pulse ring-2 ring-primary ring-offset-2' : ''}`}
                  >
                    {/* Clear mode checkmark badge */}
                    {clearSelectionMode && isSelectedForClearing && (
                      <div className="absolute -top-1 -right-1 w-4 h-4 bg-orange-600 rounded-full flex items-center justify-center">
                        <Check className="h-2.5 w-2.5 text-white" />
                      </div>
                    )}
                    {/* Generate mode checkmark badge */}
                    {generateSelectionMode && isSelectedForGenerating && (
                      <div className="absolute -top-1 -right-1 w-4 h-4 bg-primary rounded-full flex items-center justify-center">
                        <Check className="h-2.5 w-2.5 text-white" />
                      </div>
                    )}
                    <div className={`text-[10px] font-medium ${getDayAbbrevStyle()}`}>{dayAbbrev}</div>
                    <div className="text-sm font-bold">{date.getDate()}</div>
                    <div className="flex justify-center gap-0.5 h-1.5">
                      {dayMealCount > 0 ? (
                        [...Array(Math.min(dayMealCount, 4))].map((_, i) => (
                          <div
                            key={i}
                            className={`w-1 h-1 rounded-full ${getMealDotStyle()}`}
                          />
                        ))
                      ) : isToday && !isViewing && !clearSelectionMode && !generateSelectionMode ? (
                        <span className="text-[7px] text-primary font-bold">TODAY</span>
                      ) : null}
                    </div>
                  </button>
                )
              })}
            </div>
          </div>
        </div>

        {/* 3. MAIN CONTENT - Fixed height, no scroll, all 4 meals visible */}
        <div
          ref={mainContentRef}
          className="flex-1 flex flex-col overflow-hidden"
        >
          {/* Date Header - "Monday 8 December" */}
          <div className="px-3 py-1 flex-shrink-0">
            <h2 className="text-sm font-semibold">{formattedSelectedDate}</h2>
          </div>

          {/* Error message */}
          {generationError && (
            <div className="mx-3 mb-1 p-2 bg-red-50 border border-red-200 rounded-lg text-red-700 text-xs flex items-center gap-2 flex-shrink-0">
              <AlertCircle className="h-3 w-3 flex-shrink-0" />
              <span className="flex-1">{generationError}</span>
              <button onClick={() => setGenerationError(null)} className="text-red-500">
                <X className="h-3 w-3" />
              </button>
            </div>
          )}

          {/* Meal Cards - Compact, all 4 visible, NO SCROLL */}
          <div className="flex-1 px-3 pb-1 flex flex-col gap-1.5 overflow-hidden">
            {MEAL_SLOTS.map(slot => {
              const recipe = dayMeals[slot.id]
              const isSwapping = swappingSlot === slot.id
              const isExcluded = isMealExcluded(selectedDateKey, slot.id)

              return (
                <div key={slot.id} className="flex-1 min-h-0">
                  <MealSlotCard
                    key={`${slot.id}-${selectedDateKey}`}
                    slot={slot}
                    recipe={recipe}
                    onSwap={() => setSwappingSlot(isSwapping ? null : slot.id)}
                    onClear={() => handleClearSlot(slot.id)}
                    isSwapping={isSwapping}
                    members={members}
                    isHouseholdMode={isHouseholdMode}
                    compact={true}
                    isExcluded={isExcluded}
                    onToggleExclusion={() => toggleMealExclusion(selectedDateKey, slot.id)}
                  />
                </div>
              )
            })}
          </div>
        </div>

        {/* Mobile Recipe Picker Sheet - full screen when swapping */}
        {swappingSlot && (
          <RecipePickerSheet
            swappingSlot={swappingSlot}
            dayMeals={dayMeals}
            MEAL_SLOTS={MEAL_SLOTS}
            alternativeSearch={alternativeSearch}
            setAlternativeSearch={setAlternativeSearch}
            filteredAlternatives={filteredAlternatives}
            handleSwapMeal={handleSwapMeal}
            setSwappingSlot={setSwappingSlot}
          />
        )}

        {/* Floating Clear Action Bar - shows when in selection mode */}
        {clearSelectionMode && (
          <div className="fixed bottom-20 left-4 right-4 z-40 animate-in slide-in-from-bottom-4 duration-200">
            <div className="bg-orange-500 rounded-xl shadow-lg p-3">
              {/* Top row: count and buttons */}
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-white">
                  <Trash2 className="h-5 w-5" />
                  <span className="font-medium">
                    {selectedForClearing.length} day{selectedForClearing.length !== 1 ? 's' : ''}
                    {selectedClearMealCount > 0 && (
                      <span className="opacity-80 ml-1">
                        ({selectedClearMealCount} meal{selectedClearMealCount !== 1 ? 's' : ''})
                      </span>
                    )}
                  </span>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={exitClearSelectionMode}
                    className="text-white hover:bg-orange-600 hover:text-white"
                  >
                    Cancel
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleClearSelectedDays}
                    disabled={selectedForClearing.length === 0}
                    className="bg-white text-orange-600 hover:bg-orange-50"
                  >
                    Clear
                  </Button>
                </div>
              </div>

              {/* Bottom row: shopping list checkbox */}
              <label className="flex items-center gap-2 mt-2 pt-2 border-t border-orange-400/30 cursor-pointer">
                <input
                  type="checkbox"
                  checked={alsoClearShoppingList}
                  onChange={(e) => setAlsoClearShoppingList(e.target.checked)}
                  className="w-4 h-4 rounded border-white/50 bg-white/20 text-white focus:ring-white/50"
                />
                <span className="text-sm text-white/90">Also clear shopping list</span>
              </label>
            </div>
          </div>
        )}

        {/* Floating Generate Action Bar - shows when in generate selection mode */}
        {generateSelectionMode && !isGenerating && (
          <div className="fixed bottom-20 left-4 right-4 z-40 animate-in slide-in-from-bottom-4 duration-200">
            <div className="bg-primary rounded-xl shadow-lg p-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-white">
                  <Sparkles className="h-5 w-5" />
                  <span className="font-medium">
                    Generate {selectedForGenerating.length} day{selectedForGenerating.length !== 1 ? 's' : ''}
                  </span>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={exitGenerateSelectionMode}
                    className="text-white hover:bg-primary-foreground/20 hover:text-white"
                  >
                    Cancel
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleGenerateSelectedDays}
                    disabled={selectedForGenerating.length === 0}
                    className="bg-white text-primary hover:bg-primary-foreground/90"
                  >
                    Generate
                  </Button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Full-screen AI Generation Overlay */}
        {isGenerating && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
            <div className="bg-card rounded-2xl p-8 mx-4 max-w-sm w-full text-center shadow-2xl animate-in fade-in zoom-in-95 duration-200">
              <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary/10 mb-4">
                <Sparkles className="h-8 w-8 text-primary animate-pulse" />
              </div>
              <h2 className="text-xl font-semibold mb-2">Generating meals...</h2>
              <div className="flex items-center justify-center gap-2 text-muted-foreground mb-4">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span>AI is creating your meal plan</span>
              </div>
              <p className="text-sm text-muted-foreground">
                This usually takes 10-20 seconds
              </p>
            </div>
          </div>
        )}

        {/* Bottom nav spacer */}
        <div className="h-16 flex-shrink-0" />
      </div>

      {/* ===== DESKTOP LAYOUT ===== */}
      <div className="hidden md:block flex-1 p-6">
        {/* Header */}
        <div className="mb-6">
          <h1 className="text-2xl font-bold">Meal Planner</h1>
          <p className="text-sm text-muted-foreground">
            {weekDateRange ? formatDateRange(weekDateRange.first, weekDateRange.last) : 'This week'}
            {totalWeekMeals > 0 && ` Â· ${totalWeekMeals} meals planned`}
          </p>
        </div>

        {/* Error message */}
        {generationError && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            {generationError}
            <button onClick={() => setGenerationError(null)} className="ml-auto text-red-500 hover:text-red-700">
              <X className="h-4 w-4" />
            </button>
          </div>
        )}

        {/* Day Strip + Action Buttons */}
        <div className="mb-6 pb-4 border-b space-y-3">
          <div className="flex gap-1.5">
            {allDates.map((date) => {
              const dateKey = toISODate(date)
              const isViewing = isSameDay(date, selectedDate)
              const isToday = isSameDay(date, today)
              const dayMealCount = Object.keys(meals[dateKey] || {}).length
              const dayOfWeek = date.getDay()
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6
              const dayAbbrev = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek]

              return (
                <button
                  key={dateKey}
                  onClick={() => {
                    setSelectedDate(date)
                    setSwappingSlot(null)
                  }}
                  className={`flex-1 rounded-xl border-2 py-2 px-1 text-center transition-all ${
                    isViewing
                      ? 'bg-primary text-primary-foreground border-primary shadow-md'
                      : isWeekend
                        ? 'bg-muted/60 border-border hover:border-muted-foreground/50'
                        : 'bg-card border-border hover:border-muted-foreground/50'
                  }`}
                >
                  <div className="text-xs font-semibold">{dayAbbrev}</div>
                  <div className="text-base font-bold">{date.getDate()}</div>
                  <div className="flex justify-center gap-0.5 mt-1">
                    {dayMealCount > 0 ? (
                      [...Array(Math.min(dayMealCount, 4))].map((_, i) => (
                        <div key={i} className={`w-1.5 h-1.5 rounded-full ${isViewing ? 'bg-primary-foreground/80' : 'bg-primary'}`} />
                      ))
                    ) : isToday && !isViewing ? (
                      <span className="text-[10px] text-primary font-semibold">Today</span>
                    ) : (
                      <div className="h-1.5" />
                    )}
                  </div>
                </button>
              )
            })}
          </div>

          <div className="flex gap-2">
            <Button size="sm" variant="outline" onClick={() => handleGenerateWeek(false)} disabled={isGenerating || !user} className="h-auto py-2 px-3 text-xs">
              {isGenerating ? <Loader2 className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
              <span className="ml-1.5">Refresh Week</span>
            </Button>
            <Button
              size="sm"
              variant={justCommitted ? "default" : isListStale ? "default" : "outline"}
              onClick={handleCommitToShoppingList}
              disabled={totalWeekMeals === 0}
              className={`h-auto py-2 px-3 text-xs ${justCommitted ? "bg-green-600" : isListStale ? "bg-amber-500" : ""}`}
            >
              {justCommitted ? <><Check className="h-3.5 w-3.5 mr-1" />Added</> : isListStale ? <><AlertCircle className="h-3.5 w-3.5 mr-1" />Update List</> : committedHash ? <><Check className="h-3.5 w-3.5 mr-1" />In List</> : <><ShoppingCart className="h-3.5 w-3.5 mr-1" />Add to List</>}
            </Button>
          </div>
        </div>

        {/* Day Detail */}
        <div>
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">{formatDayHeader(selectedDate)}</h2>
            {Object.keys(dayMeals).length > 0 && (
              <button onClick={handlePrintDayRecipes} className="text-sm text-primary hover:underline flex items-center gap-1">
                <Printer className="h-4 w-4" /> Print Recipes
              </button>
            )}
          </div>

          <div className="space-y-4">
            {MEAL_SLOTS.map(slot => {
              const recipe = dayMeals[slot.id]
              const isSwapping = swappingSlot === slot.id
              const isExcluded = isMealExcluded(selectedDateKey, slot.id)

              return (
                <div key={`${slot.id}-${selectedDateKey}`}>
                  <MealSlotCard
                    slot={slot}
                    recipe={recipe}
                    onSwap={() => setSwappingSlot(isSwapping ? null : slot.id)}
                    onClear={() => handleClearSlot(slot.id)}
                    isSwapping={isSwapping}
                    members={members}
                    isHouseholdMode={isHouseholdMode}
                    isExcluded={isExcluded}
                    onToggleExclusion={() => toggleMealExclusion(selectedDateKey, slot.id)}
                  />

                  {isSwapping && (
                    <div className="mt-2 p-4 bg-muted/30 rounded-lg border">
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="text-sm font-medium">Choose alternative:</h4>
                        <button onClick={() => setSwappingSlot(null)} className="text-muted-foreground hover:text-foreground">
                          <X className="h-4 w-4" />
                        </button>
                      </div>
                      <div className="mb-3 space-y-2">
                        <input type="text" placeholder="Search recipes..." value={alternativeSearch} onChange={(e) => setAlternativeSearch(e.target.value)} className="w-full px-3 py-1.5 text-sm border rounded-md bg-background" />
                        <div className="flex flex-wrap gap-1">
                          {availableCategories.map(cat => (
                            <button key={cat} onClick={() => setAlternativeCategory(cat)} className={`px-2 py-0.5 text-xs rounded-full border ${alternativeCategory === cat ? 'bg-primary text-primary-foreground border-primary' : 'bg-background hover:bg-muted border-border'}`}>
                              {cat === 'all' ? 'All' : cat.replace('_', ' ')}
                            </button>
                          ))}
                        </div>
                      </div>
                      {filteredAlternatives.length > 0 ? (
                        <div className="grid grid-cols-2 gap-2 max-h-64 overflow-y-auto">
                          {filteredAlternatives.map(alt => (
                            <button key={alt.id} onClick={() => handleSwapMeal(slot.id, alt)} className="text-left p-3 bg-card border rounded-lg hover:border-primary transition-colors">
                              <div className="font-medium text-sm">{alt.name}</div>
                              <div className="text-xs text-muted-foreground mt-1">{alt.per_serve?.calories} cal Â· {alt.total_time_mins} min</div>
                            </button>
                          ))}
                        </div>
                      ) : (
                        <p className="text-sm text-muted-foreground">No alternatives available.</p>
                      )}
                    </div>
                  )}
                </div>
              )
            })}
          </div>

          {Object.keys(dayMeals).length > 0 && !isHouseholdMode && targets && (
            <div className="mt-6 p-4 bg-muted/30 rounded-lg">
              <h3 className="text-sm font-medium text-muted-foreground mb-3">Day Totals</h3>
              <div className="grid grid-cols-4 gap-4">
                <MacroProgress label="Calories" current={dayTotals.calories} target={targets.dailyCalories} />
                <MacroProgress label="Protein" current={dayTotals.protein} target={targets.protein} unit="g" />
                <MacroProgress label="Fat" current={dayTotals.fat} target={targets.fat} unit="g" />
                <MacroProgress label="Carbs" current={dayTotals.carbs} target={targets.carbs} unit="g" />
              </div>
            </div>
          )}
        </div>
      </div>
    </>
  )
}

// Sub-component: Recipe Picker Sheet (mobile full-screen)
function RecipePickerSheet({
  swappingSlot,
  dayMeals,
  MEAL_SLOTS,
  alternativeSearch,
  setAlternativeSearch,
  filteredAlternatives,
  handleSwapMeal,
  setSwappingSlot,
}) {
  const inputRef = useRef(null)
  const listRef = useRef(null)
  const hasBlurredOnMount = useRef(false)
  const [previewRecipe, setPreviewRecipe] = useState(null)
  const [keyboardHeight, setKeyboardHeight] = useState(0)

  // Blur the input only once on initial mount to prevent auto-focus
  useEffect(() => {
    if (inputRef.current && !hasBlurredOnMount.current) {
      inputRef.current.blur()
      hasBlurredOnMount.current = true
    }
  }, [])

  // Reset the flag when sheet closes (for next time it opens)
  useEffect(() => {
    return () => {
      hasBlurredOnMount.current = false
    }
  }, [])

  // Track keyboard height using visualViewport API
  useEffect(() => {
    if (typeof window === 'undefined' || !window.visualViewport) return

    const viewport = window.visualViewport

    const handleResize = () => {
      // Calculate keyboard height as difference between window and viewport height
      const keyboardH = window.innerHeight - viewport.height
      setKeyboardHeight(Math.max(0, keyboardH))
    }

    viewport.addEventListener('resize', handleResize)
    viewport.addEventListener('scroll', handleResize)

    // Initial check
    handleResize()

    return () => {
      viewport.removeEventListener('resize', handleResize)
      viewport.removeEventListener('scroll', handleResize)
    }
  }, [])

  const slotInfo = MEAL_SLOTS.find(s => s.id === swappingSlot)
  const isSwap = !!dayMeals[swappingSlot]

  // Handle selecting recipe from preview
  const handleSelectFromPreview = (recipe) => {
    handleSwapMeal(swappingSlot, recipe)
    setPreviewRecipe(null)
  }

  return (
    <>
      {/* Solid backdrop to fully cover content behind */}
      <div className="md:hidden fixed inset-0 z-[59] bg-white" />

      {/* z-[60] to cover bottom nav which is z-50 */}
      <div
        className="md:hidden fixed inset-0 z-[60] flex flex-col"
        style={{
          touchAction: 'none',
          backgroundColor: '#f8f7f4',
          // Adjust height when keyboard is open
          height: keyboardHeight > 0 ? `calc(100% - ${keyboardHeight}px)` : '100%',
        }}
      >
        {/* Header - darker shade to differentiate from Planner */}
        <div className="flex-shrink-0 safe-area-top" style={{ backgroundColor: '#2d5a3d' }}>
          {/* Drag handle */}
          <div className="flex justify-center pt-2 pb-1">
            <div className="w-12 h-1.5 bg-white/40 rounded-full" />
          </div>
          <div className="flex items-center justify-between px-4 pb-3">
            <button
              onClick={() => setSwappingSlot(null)}
              className="p-2 -ml-2 rounded-full active:bg-white/10 text-white"
            >
              <X className="h-5 w-5" />
            </button>
            <div className="text-center text-white">
              <div className="text-xs opacity-70 uppercase tracking-wider">
                {isSwap ? 'Choose replacement' : 'Add meal'}
              </div>
              <h3 className="font-bold text-lg flex items-center justify-center gap-2">
                <span>{slotInfo?.icon}</span>
                <span>{slotInfo?.label}</span>
              </h3>
            </div>
            <div className="w-9" /> {/* Spacer for centering */}
          </div>
        </div>

        {/* Search - slightly tinted background */}
        <div className="flex-shrink-0 px-4 py-3 border-b" style={{ backgroundColor: '#f8f7f4' }}>
          <input
            ref={inputRef}
            type="text"
            inputMode="search"
            enterKeyHint="search"
            autoComplete="off"
            autoCorrect="off"
            autoCapitalize="off"
            spellCheck="false"
            placeholder="Search recipes..."
            value={alternativeSearch}
            onChange={(e) => setAlternativeSearch(e.target.value)}
            className="w-full px-3 py-2.5 text-base border rounded-lg bg-white"
          />
          <p className="text-xs text-muted-foreground mt-2">
            {filteredAlternatives.length} {filteredAlternatives.length === 1 ? 'recipe' : 'recipes'} Â· Swipe right to preview
          </p>
        </div>

        {/* Recipe list - cream-tinted background, flexbox handles remaining space */}
        <div
          ref={listRef}
          className="flex-1 min-h-0 overflow-y-auto px-4 py-2 space-y-2"
          style={{ overscrollBehavior: 'contain', backgroundColor: '#f8f7f4' }}
        >
          {filteredAlternatives.length > 0 ? (
            filteredAlternatives.map(alt => (
              <PickerRecipeCard
                key={alt.id}
                recipe={alt}
                onSelect={() => handleSwapMeal(swappingSlot, alt)}
                onPreview={() => setPreviewRecipe(alt)}
              />
            ))
          ) : (
            <div className="text-center py-8 text-muted-foreground">
              <p className="text-sm">No recipes found</p>
              <p className="text-xs mt-1">Try a different search term</p>
            </div>
          )}
        </div>

        {/* Safe area for bottom - only show when keyboard is closed */}
        {keyboardHeight === 0 && (
          <div className="h-4 flex-shrink-0 safe-area-bottom" style={{ backgroundColor: '#f8f7f4' }} />
        )}
      </div>

      {/* Recipe preview overlay */}
      <RecipeOverlay
        recipe={previewRecipe}
        slot={slotInfo}
        isOpen={!!previewRecipe}
        onClose={() => setPreviewRecipe(null)}
        mode="preview"
        onSelect={handleSelectFromPreview}
      />
    </>
  )
}

// Sub-component: Swipeable recipe card in picker (swipe right to preview)
function PickerRecipeCard({ recipe, onSelect, onPreview }) {
  const [swipeOffset, setSwipeOffset] = useState(0)
  const [isSwiping, setIsSwiping] = useState(false)
  const touchStartX = useRef(0)
  const touchStartY = useRef(0)
  const isHorizontalSwipe = useRef(false)

  const PREVIEW_THRESHOLD = 80

  const handleTouchStart = useCallback((e) => {
    touchStartX.current = e.touches[0].clientX
    touchStartY.current = e.touches[0].clientY
    isHorizontalSwipe.current = false
    setIsSwiping(true)
  }, [])

  const handleTouchMove = useCallback((e) => {
    if (!isSwiping) return
    const currentX = e.touches[0].clientX
    const currentY = e.touches[0].clientY
    const diffX = currentX - touchStartX.current // Positive = swipe right
    const diffY = Math.abs(currentY - touchStartY.current)

    // Determine swipe direction on first significant movement
    if (!isHorizontalSwipe.current && (Math.abs(diffX) > 10 || diffY > 10)) {
      isHorizontalSwipe.current = Math.abs(diffX) > diffY
    }

    // Only track horizontal swipe right (for preview)
    if (isHorizontalSwipe.current && diffX > 0) {
      setSwipeOffset(Math.min(diffX, 120))
    }
  }, [isSwiping])

  const handleTouchEnd = useCallback(() => {
    setIsSwiping(false)
    isHorizontalSwipe.current = false

    if (swipeOffset >= PREVIEW_THRESHOLD) {
      // Trigger preview
      onPreview()
    }
    // Always snap back
    setSwipeOffset(0)
  }, [swipeOffset, onPreview])

  const handleTouchCancel = useCallback(() => {
    setIsSwiping(false)
    setSwipeOffset(0)
    isHorizontalSwipe.current = false
  }, [])

  // Visual feedback
  const isNearPreview = swipeOffset >= PREVIEW_THRESHOLD - 20
  const showPreviewHint = swipeOffset > 20

  return (
    <div className="relative overflow-hidden rounded-lg">
      {/* Preview button behind (left side, amber) */}
      <div
        className={`absolute left-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
          isNearPreview ? 'bg-amber-500' : 'bg-amber-400'
        }`}
        style={{ width: swipeOffset }}
      >
        {showPreviewHint && (
          <span className={`text-white text-sm font-semibold ${
            isNearPreview ? 'scale-110' : ''
          } transition-transform`}>
            {isNearPreview ? 'ðŸ‘ View' : 'Preview'}
          </span>
        )}
      </div>

      {/* Main card */}
      <div
        className="bg-white border rounded-lg border-l-4 border-l-primary/60"
        style={{
          touchAction: 'pan-y',
          transform: `translateX(${swipeOffset}px)`,
          transition: isSwiping ? 'none' : 'transform 0.2s ease-out',
        }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onTouchCancel={handleTouchCancel}
        onClick={() => !isSwiping && swipeOffset === 0 && onSelect()}
      >
        <div className="p-3">
          <div className="font-medium text-sm">{sanitizeText(recipe.name)}</div>
          <div className="text-xs text-muted-foreground mt-0.5">
            {recipe.per_serve?.calories} cal Â· {recipe.per_serve?.protein_g}P Â· {recipe.total_time_mins} min
          </div>
          {recipe.description && sanitizeText(recipe.description) && (
            <div className="text-xs text-muted-foreground/70 mt-1 line-clamp-1">
              {sanitizeText(recipe.description)}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

// Sub-component: Meal slot card
function MealSlotCard({ slot, recipe, onSwap, onClear, isSwapping, members, isHouseholdMode, compact = false, isExcluded = false, onToggleExclusion }) {
  // ALL HOOKS MUST BE AT THE TOP - before any conditional returns
  const [isOverlayOpen, setIsOverlayOpen] = useState(false)
  const [swipeOffset, setSwipeOffset] = useState(0) // Positive = swipe left (Swap), Negative = swipe right (Recipe)
  const [swipeDirection, setSwipeDirection] = useState(null) // 'left' | 'right' | null
  const [isRevealed, setIsRevealed] = useState(false) // Gmail-style: stays revealed until dismissed
  const [revealedDirection, setRevealedDirection] = useState(null) // Which direction is revealed
  const [isSwiping, setIsSwiping] = useState(false)
  const [toastMessage, setToastMessage] = useState(null) // Toast notification for exclusion toggle
  const touchStartX = useRef(0)
  const touchStartY = useRef(0)
  const lastTapTime = useRef(0)
  const isHorizontalSwipe = useRef(false)
  const cardRef = useRef(null)
  const longPressTimer = useRef(null)

  // Gmail-style swipe thresholds
  const REVEAL_THRESHOLD = 60  // Swipe this far to reveal button
  const ACTION_THRESHOLD = 140 // Swipe this far to trigger action immediately
  const REVEALED_POSITION = 80 // Where card sits when revealed

  // Calculate household portions for ingredient scaling
  const householdPortions = useMemo(() => {
    if (!isHouseholdMode || !members || members.length === 0 || !recipe) {
      return { total: 1, breakdown: [] }
    }

    const portions = members.map(member => {
      const portion = calculateMemberPortion(member, recipe, slot.id)
      return { name: member.name, portion, isPrimary: member.is_primary }
    })

    const total = portions.reduce((sum, p) => sum + p.portion, 0)

    const breakdown = portions.map(p => ({
      ...p,
      percentage: Math.round((p.portion / total) * 100)
    }))

    return { total, breakdown }
  }, [isHouseholdMode, members, recipe, slot.id])

  // Haptic feedback helper
  const triggerHaptic = useCallback(() => {
    if (typeof navigator !== 'undefined' && navigator.vibrate) {
      navigator.vibrate(10)
    }
  }, [])

  // Reset swipe state
  const resetSwipe = useCallback(() => {
    setSwipeOffset(0)
    setSwipeDirection(null)
    setIsRevealed(false)
    setRevealedDirection(null)
    lastTapTime.current = 0
  }, [])

  // Trigger swap action (swipe left) with haptic
  const triggerSwapAction = useCallback(() => {
    triggerHaptic()
    onSwap()
    resetSwipe()
  }, [onSwap, triggerHaptic, resetSwipe])

  // Trigger recipe action (swipe right) with haptic
  const triggerRecipeAction = useCallback(() => {
    triggerHaptic()
    setIsOverlayOpen(true)
    resetSwipe()
  }, [triggerHaptic, resetSwipe])

  // Long-press handlers - direct toggle with toast feedback
  const startLongPress = useCallback(() => {
    if (!recipe) return // Only for cards with meals
    longPressTimer.current = setTimeout(() => {
      triggerHaptic()
      // Direct toggle - no popup menu
      if (onToggleExclusion) {
        onToggleExclusion()
        // Show toast based on new state (opposite of current)
        const message = isExcluded
          ? 'Included in shopping list'
          : 'Excluded from shopping list'
        setToastMessage(message)
        // Auto-dismiss toast after 1.5 seconds
        setTimeout(() => setToastMessage(null), 1500)
      }
    }, 500) // 500ms for long press
  }, [recipe, triggerHaptic, onToggleExclusion, isExcluded])

  const cancelLongPress = useCallback(() => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
      longPressTimer.current = null
    }
  }, [])

  // Handle tap outside to dismiss revealed state
  const handleCardClick = useCallback((e) => {
    if (isRevealed) {
      // If revealed and tapping the card (not the button), dismiss
      resetSwipe()
      return
    }
    // No double-tap anymore - use swipe-right for recipe
  }, [isRevealed, resetSwipe])

  // Swipe handlers - Gmail-style two-stage, bidirectional
  const handleTouchStart = useCallback((e) => {
    // Prevent iOS text selection on long-press
    e.preventDefault()
    touchStartX.current = e.touches[0].clientX
    touchStartY.current = e.touches[0].clientY
    isHorizontalSwipe.current = false
    setIsSwiping(true)
    startLongPress() // Start long-press timer
  }, [startLongPress])

  const handleTouchMove = useCallback((e) => {
    if (!isSwiping) return
    const currentX = e.touches[0].clientX
    const currentY = e.touches[0].clientY
    const diffX = touchStartX.current - currentX // Positive = swipe left, Negative = swipe right
    const diffY = Math.abs(currentY - touchStartY.current)

    // Cancel long-press if user starts moving
    if (Math.abs(diffX) > 10 || diffY > 10) {
      cancelLongPress()
    }

    // Determine swipe direction on first significant movement
    if (!isHorizontalSwipe.current && (Math.abs(diffX) > 10 || diffY > 10)) {
      isHorizontalSwipe.current = Math.abs(diffX) > diffY
    }

    // Only track horizontal swipe
    if (isHorizontalSwipe.current) {
      // Determine current swipe direction
      const currentDirection = diffX > 0 ? 'left' : 'right'

      // If we're revealed in one direction and swiping the other way, reset first
      if (isRevealed && revealedDirection && currentDirection !== revealedDirection) {
        // Allow swiping back to closed from revealed position
        const baseOffset = revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION
        const newOffset = baseOffset + diffX

        // If swiping back toward center, allow it
        if ((revealedDirection === 'left' && newOffset < REVEALED_POSITION) ||
            (revealedDirection === 'right' && newOffset > -REVEALED_POSITION)) {
          setSwipeOffset(newOffset)
          // Check if we crossed zero - switch directions
          if ((revealedDirection === 'left' && newOffset < 0) ||
              (revealedDirection === 'right' && newOffset > 0)) {
            setSwipeDirection(currentDirection)
          }
          return
        }
      }

      // Normal swipe from neutral or continuing in same direction
      if (!isRevealed) {
        setSwipeDirection(currentDirection)
        // For empty cards, only allow swipe left (no recipe to view)
        if (!recipe && currentDirection === 'right') {
          return
        }
        // Clamp to max swipe distance in either direction
        const clampedOffset = Math.max(-180, Math.min(diffX, 180))
        setSwipeOffset(clampedOffset)
      } else if (revealedDirection === currentDirection) {
        // Continuing in same direction from revealed position
        const baseOffset = revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION
        const newOffset = baseOffset + diffX
        if (revealedDirection === 'left') {
          setSwipeOffset(Math.max(0, Math.min(newOffset, 180)))
        } else {
          setSwipeOffset(Math.min(0, Math.max(newOffset, -180)))
        }
      }
    }
  }, [isSwiping, isRevealed, revealedDirection, recipe])

  const handleTouchEnd = useCallback(() => {
    setIsSwiping(false)
    isHorizontalSwipe.current = false
    cancelLongPress() // Cancel any pending long-press

    const absOffset = Math.abs(swipeOffset)
    const direction = swipeOffset > 0 ? 'left' : 'right'

    // Stage 2: Past action threshold - trigger immediately
    if (absOffset >= ACTION_THRESHOLD) {
      if (direction === 'left') {
        triggerSwapAction()
      } else if (recipe) {
        triggerRecipeAction()
      } else {
        resetSwipe()
      }
      return
    }

    // Stage 1: Past reveal threshold - snap to revealed position
    if (absOffset >= REVEAL_THRESHOLD) {
      // Only reveal recipe button if there's a recipe
      if (direction === 'right' && !recipe) {
        resetSwipe()
        return
      }
      setSwipeOffset(direction === 'left' ? REVEALED_POSITION : -REVEALED_POSITION)
      setIsRevealed(true)
      setRevealedDirection(direction)
      return
    }

    // Below threshold - snap back to closed
    resetSwipe()
  }, [swipeOffset, recipe, triggerSwapAction, triggerRecipeAction, resetSwipe, cancelLongPress])

  // Handle touch cancel
  const handleTouchCancel = useCallback(() => {
    setIsSwiping(false)
    isHorizontalSwipe.current = false
    cancelLongPress() // Cancel any pending long-press
    // Snap to either revealed or closed based on current state
    if (isRevealed && revealedDirection) {
      setSwipeOffset(revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION)
    } else {
      resetSwipe()
    }
  }, [isRevealed, revealedDirection, resetSwipe, cancelLongPress])

  // Handle rating
  const handleRate = (rating) => {
    console.log('Recipe rated:', rating, recipe.id)
  }

  // Visual states for swipe-left (Swap/Add - green, right side)
  const swipeLeftOffset = Math.max(0, swipeOffset)
  const isNearSwapAction = swipeLeftOffset >= ACTION_THRESHOLD - 20
  const showSwapButton = swipeLeftOffset > 30 || (isRevealed && revealedDirection === 'left')

  // Visual states for swipe-right (Recipe - yellow, left side)
  const swipeRightOffset = Math.abs(Math.min(0, swipeOffset))
  const isNearRecipeAction = swipeRightOffset >= ACTION_THRESHOLD - 20
  const showRecipeButton = swipeRightOffset > 30 || (isRevealed && revealedDirection === 'right')

  // Early return for empty slot - AFTER all hooks
  if (!recipe) {
    // COMPACT MODE (mobile) - swipeable empty card with Gmail-style reveal (only swipe-left for Add)
    if (compact) {
      return (
        <div className="relative overflow-hidden rounded-lg h-full">
          {/* Add button behind the card (right side, green) */}
          <div
            className={`absolute right-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearSwapAction ? 'bg-primary' : 'bg-primary/80'
            }`}
            style={{ width: swipeLeftOffset }}
          >
            {showSwapButton && (
              <button
                onClick={triggerSwapAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-primary-foreground text-sm font-semibold ${
                  isNearSwapAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearSwapAction ? '+ Add' : 'Add'}
                </span>
              </button>
            )}
          </div>

          {/* Main card content - slides based on swipe direction */}
          <div
            ref={cardRef}
            className="bg-card border rounded-lg h-full"
            style={{
              touchAction: 'pan-y',
              transform: `translateX(${-swipeLeftOffset}px)`,
              transition: isSwiping ? 'none' : 'transform 0.2s ease-out',
            }}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onTouchCancel={handleTouchCancel}
            onClick={handleCardClick}
          >
            <div className="p-2 h-full flex flex-col justify-center">
              {/* Line 1: Icon + LUNCH + 12:00 */}
              <div className="flex items-center gap-1 text-[11px] text-muted-foreground">
                <span className="text-sm">{slot.icon}</span>
                <span className="uppercase font-semibold tracking-wide">{slot.label}</span>
                <span className="text-muted-foreground/50">Â·</span>
                <span>{slot.time}</span>
              </div>
              {/* Line 2: Empty state message */}
              <h3 className="text-sm font-medium leading-tight text-muted-foreground/60">
                No meal planned
              </h3>
              {/* Line 3: Hint */}
              <p className="text-[11px] text-muted-foreground/40 leading-tight">
                {isRevealed ? 'Tap Add or swipe more' : 'Swipe left to add'}
              </p>
            </div>
          </div>
        </div>
      )
    }

    // DESKTOP MODE - simple empty state
    return (
      <div className="border border-dashed rounded-lg flex items-center justify-between p-4">
        <div className="flex items-center gap-2 text-muted-foreground">
          <span className="text-xl">{slot.icon}</span>
          <span className="text-base">{slot.label}</span>
          <span className="text-xs text-muted-foreground/60">Â· {slot.time}</span>
        </div>
        <Button variant="ghost" size="sm" onClick={onSwap}>
          Add
        </Button>
      </div>
    )
  }

  const macros = recipe.per_serve || {}

  // COMPACT MODE (mobile) - compact card with bidirectional Gmail-style swipe
  // Swipe left â†’ Swap (green), Swipe right â†’ Recipe (yellow)
  if (compact) {
    // Calculate card transform based on bidirectional swipe
    const cardTransform = swipeOffset > 0
      ? -swipeLeftOffset  // Swiping left - card moves left
      : swipeRightOffset  // Swiping right - card moves right

    return (
      <>
        <div className="relative overflow-hidden rounded-lg h-full">
          {/* Recipe button behind the card (LEFT side, yellow) - swipe right reveals */}
          <div
            className={`absolute left-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearRecipeAction ? 'bg-amber-500' : 'bg-amber-400'
            }`}
            style={{ width: swipeRightOffset }}
          >
            {showRecipeButton && (
              <button
                onClick={triggerRecipeAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-white text-sm font-semibold flex items-center gap-1 ${
                  isNearRecipeAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearRecipeAction ? 'ðŸ“– View' : 'Recipe'}
                </span>
              </button>
            )}
          </div>

          {/* Swap button behind the card (RIGHT side, green) - swipe left reveals */}
          <div
            className={`absolute right-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearSwapAction ? 'bg-primary' : 'bg-primary/80'
            }`}
            style={{ width: swipeLeftOffset }}
          >
            {showSwapButton && (
              <button
                onClick={triggerSwapAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-primary-foreground text-sm font-semibold ${
                  isNearSwapAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearSwapAction ? 'â†» Swap' : 'Swap'}
                </span>
              </button>
            )}
          </div>

          {/* Main card content - slides based on swipe direction */}
          <div
            ref={cardRef}
            className={`border rounded-lg h-full select-none ${isSwapping ? 'border-primary border-2' : ''} ${isExcluded ? 'bg-muted/60 border-dashed' : 'bg-card'}`}
            style={{
              touchAction: 'pan-y',
              transform: `translateX(${cardTransform}px)`,
              transition: isSwiping ? 'none' : 'transform 0.2s ease-out',
              WebkitTouchCallout: 'none',
              WebkitUserSelect: 'none',
            }}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onTouchCancel={handleTouchCancel}
            onClick={handleCardClick}
          >
            <div className="p-2 h-full flex flex-col justify-center">
              {/* Line 1: Icon + LUNCH + 12:00 + 10 min + excluded indicator */}
              <div className="flex items-center gap-1 text-[11px] text-muted-foreground">
                <span className="text-sm">{slot.icon}</span>
                <span className="uppercase font-semibold tracking-wide">{slot.label}</span>
                <span className="text-muted-foreground/50">Â·</span>
                <span>{slot.time}</span>
                {recipe.total_time_mins && (
                  <>
                    <span className="text-muted-foreground/50">Â·</span>
                    <span>{recipe.total_time_mins}m</span>
                  </>
                )}
                {isExcluded && (
                  <span className="ml-auto flex items-center gap-0.5 text-amber-600" title="Excluded from shopping list">
                    <ShoppingCart className="h-3 w-3" />
                    <X className="h-2.5 w-2.5 -ml-1" />
                  </span>
                )}
              </div>
              {/* Line 2: Meal title */}
              <h3 className={`text-sm font-medium leading-tight line-clamp-1 ${isExcluded ? 'text-muted-foreground' : ''}`}>
                {sanitizeText(recipe.name)}
              </h3>
              {/* Line 3: Description (single line with ellipsis) */}
              {recipe.description && sanitizeDescription(recipe.description) && (
                <p className="text-[11px] text-muted-foreground leading-tight line-clamp-1">
                  {sanitizeDescription(recipe.description)}
                </p>
              )}
            </div>
          </div>
        </div>

        {/* Toast notification for exclusion toggle */}
        {toastMessage && (
          <div className="fixed bottom-20 left-1/2 -translate-x-1/2 z-50 animate-in fade-in slide-in-from-bottom-4 duration-200">
            <div className="bg-foreground text-background px-4 py-2 rounded-lg shadow-lg text-sm font-medium flex items-center gap-2">
              <ShoppingCart className="h-4 w-4" />
              {toastMessage}
            </div>
          </div>
        )}

        {/* Full-screen recipe overlay */}
        <RecipeOverlay
          recipe={recipe}
          slot={slot}
          isOpen={isOverlayOpen}
          onClose={() => setIsOverlayOpen(false)}
          onRate={handleRate}
          householdPortions={householdPortions}
          isHouseholdMode={isHouseholdMode}
          onSwap={onSwap}
          onClear={onClear}
        />
      </>
    )
  }

  // FULL MODE (desktop)
  return (
    <>
      <div className={`relative border rounded-xl overflow-hidden ${isSwapping ? 'border-primary border-2' : ''} ${isExcluded ? 'opacity-70' : ''}`}>
        {/* Main card content */}
        <div className="relative bg-card">
          <div className="p-4">
            {/* Meal type / time row */}
            <div className="flex items-center gap-2 text-xs text-muted-foreground mb-1.5">
              <span className="text-base">{slot.icon}</span>
              <span className="uppercase tracking-wide font-medium">{slot.label}</span>
              <span className="text-muted-foreground/50">â€¢</span>
              <span>{slot.time}</span>
              {isExcluded && (
                <span className="flex items-center gap-0.5 text-amber-600 ml-2" title="Excluded from shopping list">
                  <ShoppingCart className="h-3.5 w-3.5" />
                  <X className="h-3 w-3 -ml-1" />
                </span>
              )}
              {recipe.total_time_mins && (
                <span className="flex items-center gap-1 ml-auto">
                  <Clock className="h-3.5 w-3.5" />
                  {recipe.total_time_mins} min
                </span>
              )}
            </div>

            {/* Recipe title */}
            <h3 className={`text-base font-medium leading-tight ${isExcluded ? 'text-muted-foreground' : ''}`}>
              {sanitizeText(recipe.name)}
            </h3>

            {/* Description */}
            {recipe.description && sanitizeDescription(recipe.description) && (
              <p className="text-sm text-muted-foreground mt-1 leading-relaxed">
                {sanitizeDescription(recipe.description)}
              </p>
            )}

            {/* Macros */}
            <div className="flex gap-3 mt-2 text-xs text-muted-foreground">
              <span>{macros.calories} cal</span>
              <span>{macros.protein_g}P</span>
              <span>{macros.fat_g}F</span>
              <span>{macros.carbs_g}C</span>
            </div>
          </div>

          {/* Action buttons */}
          <div className="flex items-center gap-3 px-4 py-2 bg-muted/20 border-t">
            <button
              onClick={() => setIsOverlayOpen(true)}
              className="text-sm text-primary hover:underline"
            >
              View recipe
            </button>
            <span className="text-muted-foreground/30">|</span>
            <button
              onClick={onSwap}
              className={`text-sm hover:underline ${isSwapping ? 'text-primary font-medium' : 'text-muted-foreground'}`}
            >
              <RefreshCw className="h-3 w-3 inline mr-1" />
              Swap
            </button>
            <button
              onClick={onClear}
              className="text-sm text-muted-foreground hover:text-destructive hover:underline"
            >
              Remove
            </button>
            <span className="text-muted-foreground/30">|</span>
            <button
              onClick={onToggleExclusion}
              className={`text-sm hover:underline ${isExcluded ? 'text-amber-600' : 'text-muted-foreground'}`}
              title={isExcluded ? 'Include in shopping list' : 'Exclude from shopping list'}
            >
              <ShoppingCart className="h-3 w-3 inline mr-1" />
              {isExcluded ? 'Include' : 'Exclude'}
            </button>
          </div>
        </div>
      </div>

      {/* Full-screen recipe overlay */}
      <RecipeOverlay
        recipe={recipe}
        slot={slot}
        isOpen={isOverlayOpen}
        onClose={() => setIsOverlayOpen(false)}
        onRate={handleRate}
        householdPortions={householdPortions}
        isHouseholdMode={isHouseholdMode}
      />
    </>
  )
}

// Sub-component: Macro progress bar
function MacroProgress({ label, current, target, unit = '' }) {
  const percentage = target > 0 ? Math.min((current / target) * 100, 100) : 0
  const isOver = current > target
  
  return (
    <div>
      <div className="flex justify-between text-sm mb-1">
        <span className="text-muted-foreground">{label}</span>
        <span className={isOver ? 'text-amber-600 font-medium' : ''}>
          {Math.round(current)}{unit} / {target}{unit}
        </span>
      </div>
      <div className="h-2 bg-muted rounded-full overflow-hidden">
        <div 
          className={`h-full transition-all ${isOver ? 'bg-amber-500' : 'bg-primary'}`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}
