'use client'

// Batch 5 - Cleaner Mobile Layout
import { useState, useMemo, useEffect, useRef, useCallback } from 'react'
import { useUser } from '@/context/UserContext'
import { Button } from '@/components/ui/button'
import {
  getDatesFromStart,
  formatDateRange,
  formatDayTab,
  formatDayHeader,
  isSameDay,
  toISODate
} from '@/lib/dates'
import { generateDayMeals, getAlternativesForSlot } from '@/lib/mealPlanner'
import {
  generateSmartWeek,
  generateSmartWeekForHousehold,
  calculateMemberPortion,
  calculateMemberDayTotals,
  formatPortion
} from '@/lib/smartPlanner'
import { generateShoppingList, saveShoppingList, loadShoppingList, generateMealPlanHash } from '@/lib/shoppingList'
import { RefreshCw, X, Clock, ShoppingCart, Check, AlertCircle, Sparkles, Loader2, Printer, ListPlus } from 'lucide-react'
import { toAustralianName, formatQuantity } from '@/lib/ingredientFormat'
import RecipeOverlay from '@/components/RecipeOverlay'

// Helper to sanitize text (remove IP addresses and URLs from any string)
const sanitizeText = (text) => {
  if (!text) return ''
  return text
    // Remove IP addresses (e.g., 192.168.20.10)
    .replace(/\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, '')
    // Remove URLs
    .replace(/https?:\/\/[^\s]+/g, '')
    // Remove localhost references
    .replace(/localhost:\d+/gi, '')
    // Clean up any double spaces
    .replace(/\s{2,}/g, ' ')
    .trim()
}

// Alias for backward compatibility
const sanitizeDescription = sanitizeText

// Meal slots for the day (16:8 fasting window: 12:00-20:00)
const MEAL_SLOTS = [
  { id: 'lunch', label: 'Lunch', icon: 'ðŸ¥—', time: '12:00' },
  { id: 'snack_afternoon', label: 'Afternoon Snack', icon: 'ðŸŽ', time: '15:00' },
  { id: 'dinner', label: 'Dinner', icon: 'ðŸ½ï¸', time: '18:00' },
  { id: 'snack_evening', label: 'Evening Snack', icon: 'ðŸ«', time: '19:30' },
]

// Number of days to show in slider
const VISIBLE_DAYS = 7

export default function WeekView() {
  const {
    user,
    targets,
    household,
    members,
    activeMember,
    setActiveMember,
    isHouseholdMode,
    householdDietaryRestrictions
  } = useUser()

  // Today is always the starting point
  const today = useMemo(() => {
    const d = new Date()
    d.setHours(0, 0, 0, 0)
    return d
  }, [])

  // Generate dates starting from today
  const allDates = useMemo(() => getDatesFromStart(today, VISIBLE_DAYS), [today])

  // LocalStorage key for this user's meals
  const storageKey = user ? `meal-plan-${user.id}` : 'meal-plan-guest'

  // Refs for scrolling and auto-generation tracking
  const scrollContainerRef = useRef(null)
  const mainContentRef = useRef(null)
  const hasAutoGenerated = useRef(false)

  // State - initialize with defaults, hydrate in useEffect to avoid SSR mismatch
  const [selectedDate, setSelectedDateState] = useState(today)

  // Wrapper to also dispatch event when date changes and scroll to top
  const setSelectedDate = (date) => {
    setSelectedDateState(date)
    // Notify sidebar of date change
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('planner-date-changed', {
        detail: { date: toISODate(date) }
      }))
    }
    // Scroll main content to top when changing days
    if (mainContentRef.current) {
      mainContentRef.current.scrollTo({ top: 0, behavior: 'smooth' })
    }
  }
  const [meals, setMeals] = useState({})
  const [isHydrated, setIsHydrated] = useState(false)
  const [isInitialLoading, setIsInitialLoading] = useState(true) // For initial auto-generation loading state

  // Hydrate from localStorage after mount (avoids SSR mismatch)
  useEffect(() => {
    setSelectedDate(today)

    // Load meals from localStorage
    if (storageKey) {
      try {
        const saved = localStorage.getItem(storageKey)
        if (saved) {
          setMeals(JSON.parse(saved))
        }
      } catch (e) {
        console.error('Failed to load meals from localStorage:', e)
      }
    }

    setIsHydrated(true)
  }, [])
  
  const [swappingSlot, setSwappingSlot] = useState(null)
  const [alternativeSearch, setAlternativeSearch] = useState('')
  const [alternativeCategory, setAlternativeCategory] = useState('all')
  const [justCommitted, setJustCommitted] = useState(false)
  const [committedHash, setCommittedHash] = useState(null)
  const [isGenerating, setIsGenerating] = useState(false)
  const [generationError, setGenerationError] = useState(null)
  const [showGenerateModal, setShowGenerateModal] = useState(false)

  // Load committed hash on mount
  useEffect(() => {
    if (user) {
      const saved = loadShoppingList(user.id)
      if (saved?.mealPlanHash) {
        setCommittedHash(saved.mealPlanHash)
      }
    }
  }, [user?.id])
  
  // Save to localStorage whenever meals change
  const saveMeals = (newMeals) => {
    setMeals(newMeals)
    if (typeof window !== 'undefined') {
      try {
        localStorage.setItem(storageKey, JSON.stringify(newMeals))
      } catch (e) {
        console.error('Failed to save meals to localStorage:', e)
      }
    }
  }
  
  // Reload from localStorage when user changes
  useEffect(() => {
    if (isHydrated && user) {
      try {
        const saved = localStorage.getItem(storageKey)
        setMeals(saved ? JSON.parse(saved) : {})
      } catch (e) {
        console.error('Failed to reload meals:', e)
      }
    }
  }, [user?.id, isHydrated, storageKey])
  
  // Get meals for selected day
  const selectedDateKey = toISODate(selectedDate)
  const dayMeals = meals[selectedDateKey] || {}
  
  // Get all used recipe IDs (for variety)
  const usedRecipeIds = useMemo(() => {
    const ids = []
    Object.values(meals).forEach(dayMeals => {
      Object.values(dayMeals).forEach(recipe => {
        if (recipe?.id && !ids.includes(recipe.id)) {
          ids.push(recipe.id)
        }
      })
    })
    return ids
  }, [meals])
  
  // Calculate day totals
  const dayTotals = useMemo(() => {
    if (isHouseholdMode && activeMember) {
      return calculateMemberDayTotals(dayMeals, activeMember)
    }

    const totals = { calories: 0, protein: 0, fat: 0, carbs: 0 }
    Object.values(dayMeals).forEach(recipe => {
      if (recipe?.per_serve) {
        totals.calories += recipe.per_serve.calories || 0
        totals.protein += recipe.per_serve.protein_g || 0
        totals.fat += recipe.per_serve.fat_g || 0
        totals.carbs += recipe.per_serve.carbs_g || 0
      }
    })
    return totals
  }, [dayMeals, isHouseholdMode, activeMember])

  // Check if current week has any meals
  const currentWeekHasMeals = useMemo(() => {
    return allDates.some(date => {
      const dateKey = toISODate(date)
      return Object.keys(meals[dateKey] || {}).length > 0
    })
  }, [allDates, meals])

  // Count total meals in current week
  const totalWeekMeals = useMemo(() => {
    let count = 0
    allDates.forEach(date => {
      const dateKey = toISODate(date)
      count += Object.keys(meals[dateKey] || {}).length
    })
    return count
  }, [allDates, meals])

  // Generate meals using AI for the week (auto or manual refresh)
  const handleGenerateWeek = useCallback(async (isAutoGenerate = false) => {
    if (!user || !targets) {
      if (!isAutoGenerate) {
        setGenerationError('Please set up your profile first')
      }
      setIsInitialLoading(false)
      return
    }

    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result

      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        })
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply generated meals to all 7 days
      const newMeals = { ...meals }
      const planKeys = Object.keys(result.weekPlan)
      allDates.forEach((date, index) => {
        const dateKey = toISODate(date)
        // Use modulo in case we have more days than generated
        const planIndex = index % planKeys.length
        if (result.weekPlan[planIndex]?.meals) {
          newMeals[dateKey] = result.weekPlan[planIndex].meals
        }
      })

      saveMeals(newMeals)
      setSwappingSlot(null)

      console.log('Smart generation cost:', result.usage?.estimated_cost)

    } catch (error) {
      console.error('Smart generation failed:', error)
      if (!isAutoGenerate) {
        setGenerationError(error.message || 'Failed to generate meals')
      }
    } finally {
      setIsGenerating(false)
      setIsInitialLoading(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, allDates, saveMeals])

  // Show modal on first load if no meals exist (instead of auto-generating)
  useEffect(() => {
    if (isHydrated && user && targets && !hasAutoGenerated.current && !currentWeekHasMeals) {
      hasAutoGenerated.current = true
      setShowGenerateModal(true) // Show modal instead of auto-generating
      setIsInitialLoading(false)
    } else if (isHydrated) {
      setIsInitialLoading(false)
    }
  }, [isHydrated, user, targets, currentWeekHasMeals])

  // Get days that need meals (empty days)
  const emptyDays = useMemo(() => {
    return allDates.filter(date => {
      const dateKey = toISODate(date)
      return Object.keys(meals[dateKey] || {}).length === 0
    })
  }, [allDates, meals])

  // Generate meals for a single day
  const handleGenerateDay = useCallback(async () => {
    if (!user || !targets) {
      setGenerationError('Please set up your profile first')
      return
    }

    setShowGenerateModal(false)
    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result
      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        })
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply only to selected day
      const newMeals = { ...meals }
      if (result.weekPlan[0]?.meals) {
        newMeals[selectedDateKey] = result.weekPlan[0].meals
      }
      saveMeals(newMeals)

    } catch (error) {
      console.error('Day generation failed:', error)
      setGenerationError(error.message || 'Failed to generate meals')
    } finally {
      setIsGenerating(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, selectedDateKey, saveMeals])

  // Generate meals only for empty days
  const handleFillEmptyDays = useCallback(async () => {
    if (!user || !targets) {
      setGenerationError('Please set up your profile first')
      return
    }

    if (emptyDays.length === 0) {
      setShowGenerateModal(false)
      return
    }

    setShowGenerateModal(false)
    setIsGenerating(true)
    setGenerationError(null)

    try {
      let result
      if (isHouseholdMode && members.length > 0) {
        result = await generateSmartWeekForHousehold(members, {
          batchFriendly: true,
          ...householdDietaryRestrictions,
        })
      } else {
        result = await generateSmartWeek(user, targets, {
          dairyFree: false,
          glutenFree: false,
          batchFriendly: true,
        })
      }

      // Apply only to empty days
      const newMeals = { ...meals }
      const planKeys = Object.keys(result.weekPlan)
      emptyDays.forEach((date, index) => {
        const dateKey = toISODate(date)
        const planIndex = index % planKeys.length
        if (result.weekPlan[planIndex]?.meals) {
          newMeals[dateKey] = result.weekPlan[planIndex].meals
        }
      })
      saveMeals(newMeals)

    } catch (error) {
      console.error('Fill empty days failed:', error)
      setGenerationError(error.message || 'Failed to generate meals')
    } finally {
      setIsGenerating(false)
    }
  }, [user, targets, isHouseholdMode, members, householdDietaryRestrictions, meals, emptyDays, saveMeals])
  
  // Swap a meal in a slot
  const handleSwapMeal = (slotId, newRecipe) => {
    saveMeals({
      ...meals,
      [selectedDateKey]: {
        ...meals[selectedDateKey],
        [slotId]: newRecipe
      }
    })
    setSwappingSlot(null)
  }
  
  // Clear a slot
  const handleClearSlot = (slotId) => {
    const newDayMeals = { ...meals[selectedDateKey] }
    delete newDayMeals[slotId]
    saveMeals({
      ...meals,
      [selectedDateKey]: newDayMeals
    })
    setSwappingSlot(null)
  }
  
  // Print day's recipes
  const handlePrintDayRecipes = () => {
    const dateLabel = formatDayHeader(selectedDate)
    
    // Build print content
    let html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>Meal Plan - ${dateLabel}</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
          h1 { font-size: 24px; margin-bottom: 8px; }
          .subtitle { color: #666; margin-bottom: 24px; }
          .recipe { margin-bottom: 32px; page-break-inside: avoid; }
          .recipe-header { border-bottom: 2px solid #333; padding-bottom: 8px; margin-bottom: 12px; }
          .recipe-title { font-size: 18px; font-weight: 600; margin: 0; }
          .recipe-meta { font-size: 12px; color: #666; margin-top: 4px; }
          .section-title { font-size: 14px; font-weight: 600; margin: 16px 0 8px 0; }
          .ingredients { list-style: none; padding: 0; }
          .ingredients li { padding: 4px 0; display: flex; gap: 12px; }
          .ingredients .amount { color: #666; min-width: 60px; }
          .instructions { padding-left: 20px; }
          .instructions li { padding: 4px 0; }
          .portions { font-size: 12px; color: #666; margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee; }
          .batch-note { font-size: 12px; color: #666; font-style: italic; margin-top: 8px; }
          @media print { .recipe { page-break-inside: avoid; } }
        </style>
      </head>
      <body>
        <h1>${dateLabel}</h1>
        <div class="subtitle">Meal Plan${isHouseholdMode && members.length > 0 ? ` for ${members.map(m => m.name).join(' & ')}` : ''}</div>
    `
    
    MEAL_SLOTS.forEach(slot => {
      const recipe = dayMeals[slot.id]
      if (!recipe) return
      
      // Calculate household portions
      let householdTotal = 1
      let portionBreakdown = []
      
      if (isHouseholdMode && members && members.length > 0) {
        const portions = members.map(member => {
          const portion = calculateMemberPortion(member, recipe, slot.id)
          return { name: member.name, portion }
        })
        householdTotal = portions.reduce((sum, p) => sum + p.portion, 0)
        portionBreakdown = portions.map(p => ({
          name: p.name,
          percentage: Math.round((p.portion / householdTotal) * 100)
        }))
      }
      
      html += `
        <div class="recipe">
          <div class="recipe-header">
            <h2 class="recipe-title">${slot.icon} ${slot.label}: ${recipe.name}</h2>
            <div class="recipe-meta">${slot.time} Â· ${recipe.total_time_mins || '?'} min Â· ${recipe.per_serve?.calories || '?'} cal</div>
          </div>
          
          <div class="section-title">Ingredients${householdTotal > 1 ? ` (serves ${members.length})` : ''}</div>
          <ul class="ingredients">
      `
      
      recipe.ingredients?.forEach(ing => {
        // Divide by base_servings first (recipe amounts are for base_servings), then multiply by household needs
        const baseServings = recipe.base_servings || 1
        const perServeGrams = (ing.grams || 0) / baseServings
        const scaledGrams = householdTotal > 1 ? perServeGrams * householdTotal : perServeGrams
        const auName = toAustralianName(ing.name)
        const qty = formatQuantity(scaledGrams, ing.name)
        html += `<li><span class="amount">${qty}</span><span>${auName}${ing.notes ? ` (${ing.notes})` : ''}</span></li>`
      })
      
      html += `</ul>`
      
      if (portionBreakdown.length > 0) {
        html += `<div class="portions"><strong>Portions:</strong> ${portionBreakdown.map(p => `${p.name}: ${p.percentage}%`).join(' Â· ')}</div>`
      }
      
      html += `<div class="section-title">Method</div><ol class="instructions">`
      
      recipe.instructions?.forEach(step => {
        html += `<li>${step}</li>`
      })
      
      html += `</ol>`
      
      if (recipe.batch_notes) {
        html += `<div class="batch-note">ðŸ’¡ ${recipe.batch_notes}</div>`
      }
      
      html += `</div>`
    })
    
    html += `</body></html>`
    
    // Open print window
    const printWindow = window.open('', '_blank')
    printWindow.document.write(html)
    printWindow.document.close()
    printWindow.print()
  }
  
  // Get alternatives for current swap
  // Only exclude recipes used on the SAME day (not entire week - too restrictive for swapping)
  const alternatives = useMemo(() => {
    if (!swappingSlot) return []
    const currentRecipe = dayMeals[swappingSlot]
    const sameDayRecipeIds = Object.values(dayMeals)
      .filter(r => r?.id)
      .map(r => r.id)
    return getAlternativesForSlot(
      swappingSlot, 
      currentRecipe?.id, 
      sameDayRecipeIds
    )
  }, [swappingSlot, dayMeals])
  
  // Filter alternatives by search and category
  const filteredAlternatives = useMemo(() => {
    let filtered = alternatives
    
    // Text search
    if (alternativeSearch.trim()) {
      const search = alternativeSearch.toLowerCase()
      filtered = filtered.filter(r => 
        r.name.toLowerCase().includes(search) ||
        r.description?.toLowerCase().includes(search)
      )
    }
    
    // Category filter
    if (alternativeCategory !== 'all') {
      filtered = filtered.filter(r => r.category === alternativeCategory)
    }
    
    return filtered
  }, [alternatives, alternativeSearch, alternativeCategory])
  
  // Get unique categories from alternatives
  const availableCategories = useMemo(() => {
    const cats = new Set(alternatives.map(r => r.category).filter(Boolean))
    return ['all', ...Array.from(cats).sort()]
  }, [alternatives])
  
  // Reset filters when slot changes
  useEffect(() => {
    setAlternativeSearch('')
    setAlternativeCategory('all')
  }, [swappingSlot])

  // Get all date keys for current week
  const weekDateKeys = useMemo(() => {
    return allDates.map(d => toISODate(d))
  }, [allDates])

  // Calculate current meal plan hash (for current week)
  const currentHash = useMemo(() => {
    return generateMealPlanHash(meals, weekDateKeys)
  }, [meals, weekDateKeys])

  // Check if shopping list is stale
  const isListStale = committedHash && currentHash !== committedHash

  // Get week date range for display
  const weekDateRange = useMemo(() => {
    if (allDates.length === 0) return null
    return { first: allDates[0], last: allDates[allDates.length - 1] }
  }, [allDates])

  // Commit to shopping list (for current week)
  const handleCommitToShoppingList = () => {
    if (!user) return
    if (totalWeekMeals === 0) return

    const shoppingList = isHouseholdMode && members.length > 0
      ? generateShoppingList(meals, weekDateKeys, members)
      : generateShoppingList(meals, weekDateKeys, 1)

    const weekLabel = weekDateRange
      ? formatDateRange(weekDateRange.first, weekDateRange.last)
      : 'This week'
    const hash = generateMealPlanHash(meals, weekDateKeys)

    saveShoppingList(user.id, shoppingList, weekLabel, hash)
    setCommittedHash(hash)

    setJustCommitted(true)
    setTimeout(() => setJustCommitted(false), 2000)
  }

  // Format selected date for display - e.g., "Monday 8 December"
  const formattedSelectedDate = useMemo(() => {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    return `${days[selectedDate.getDay()]} ${selectedDate.getDate()} ${months[selectedDate.getMonth()]}`
  }, [selectedDate])

  // Show loading state during initial auto-generation
  if (isInitialLoading && isGenerating) {
    return (
      <div className="flex-1 flex flex-col">
        {/* Mobile Header - Green bar */}
        <div className="md:hidden bg-primary text-primary-foreground px-4 py-3 safe-area-top">
          <h1 className="text-center font-semibold">Meal Planner</h1>
        </div>

        {/* Desktop Header */}
        <div className="hidden md:block p-6 pb-0">
          <h1 className="text-2xl font-bold">Meal Planner</h1>
          <p className="text-sm text-muted-foreground">
            {weekDateRange ? formatDateRange(weekDateRange.first, weekDateRange.last) : 'This week'}
          </p>
        </div>

        {/* Loading state */}
        <div className="flex-1 flex flex-col items-center justify-center py-16">
          <div className="relative">
            <Loader2 className="h-12 w-12 animate-spin text-primary" />
            <Sparkles className="h-5 w-5 text-primary absolute -top-1 -right-1" />
          </div>
          <p className="text-lg font-medium mt-4">Planning your week...</p>
          <p className="text-sm text-muted-foreground mt-1">
            Creating meals based on your targets
          </p>
        </div>

        {/* Skeleton meal cards */}
        <div className="space-y-3 px-4 pb-4">
          {MEAL_SLOTS.map((slot) => (
            <div key={slot.id} className="border rounded-xl p-4 animate-pulse">
              <div className="flex items-center gap-2 mb-2">
                <div className="h-4 w-4 bg-muted rounded" />
                <div className="h-4 w-20 bg-muted rounded" />
              </div>
              <div className="h-5 w-48 bg-muted rounded mb-2" />
              <div className="h-4 w-full bg-muted rounded" />
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <>
      {/* ===== GENERATE MODAL ===== */}
      {showGenerateModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
          <div className="bg-card rounded-xl p-6 max-w-sm w-full shadow-xl">
            <div className="flex items-center gap-2 mb-4">
              <Sparkles className="h-5 w-5 text-primary" />
              <h2 className="text-lg font-semibold">Generate Meals</h2>
            </div>

            <div className="space-y-3">
              <Button
                onClick={handleGenerateDay}
                disabled={isGenerating}
                className="w-full justify-start h-auto py-3"
              >
                {isGenerating ? (
                  <Loader2 className="h-4 w-4 animate-spin mr-3" />
                ) : (
                  <Sparkles className="h-4 w-4 mr-3" />
                )}
                <span>Generate Day</span>
              </Button>

              <Button
                onClick={handleFillEmptyDays}
                disabled={isGenerating || emptyDays.length === 0}
                variant="outline"
                className="w-full justify-start h-auto py-3 flex-col items-start"
              >
                <div className="flex items-center w-full">
                  {isGenerating ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-3" />
                  ) : (
                    <Sparkles className="h-4 w-4 mr-3" />
                  )}
                  <span>Fill Empty Days</span>
                  {emptyDays.length > 0 && (
                    <span className="ml-auto text-xs text-muted-foreground">
                      {emptyDays.length} day{emptyDays.length !== 1 ? 's' : ''}
                    </span>
                  )}
                </div>
                <span className="text-xs text-muted-foreground mt-1 ml-7">
                  Keeps your existing meals, fills the gaps
                </span>
              </Button>

              <Button
                variant="ghost"
                onClick={() => setShowGenerateModal(false)}
                disabled={isGenerating}
                className="w-full"
              >
                Cancel
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* ===== MOBILE LAYOUT ===== */}
      <div
        className="md:hidden flex flex-col h-full overflow-hidden"
        style={{ overscrollBehavior: 'none' }}
      >
        {/* 1. HEADER BAR - Fixed at top, green background */}
        <div className="bg-primary text-primary-foreground safe-area-top flex-shrink-0">
          <div className="flex items-center justify-between h-11 px-4">
            {/* Left: AI/Sparkle icon */}
            <button
              onClick={() => setShowGenerateModal(true)}
              disabled={isGenerating}
              className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/10 active:bg-white/20 disabled:opacity-50"
            >
              {isGenerating ? (
                <Loader2 className="h-5 w-5 animate-spin" />
              ) : (
                <Sparkles className="h-5 w-5" />
              )}
            </button>
            {/* Center: Title */}
            <h1 className="font-semibold text-base">Meal Planner</h1>
            {/* Right: Print icon */}
            <button
              onClick={handlePrintDayRecipes}
              disabled={Object.keys(dayMeals).length === 0}
              className="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/10 active:bg-white/20 disabled:opacity-50"
            >
              <Printer className="h-5 w-5" />
            </button>
          </div>

          {/* 2. DAY STRIP - Below header, horizontally scrollable */}
          <div className="bg-card border-b px-2 py-1.5">
            <div
              ref={scrollContainerRef}
              className="flex gap-1 overflow-x-auto snap-x snap-mandatory scroll-smooth"
              style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
            >
              {allDates.map((date) => {
                const dateKey = toISODate(date)
                const isViewing = isSameDay(date, selectedDate)
                const isToday = isSameDay(date, today)
                const dayMealCount = Object.keys(meals[dateKey] || {}).length
                const dayOfWeek = date.getDay()
                const dayAbbrev = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek]

                return (
                  <button
                    key={dateKey}
                    onClick={() => {
                      setSelectedDate(date)
                      setSwappingSlot(null)
                    }}
                    className={`flex-shrink-0 w-[calc((100%-20px)/5)] min-w-[50px] rounded-lg py-1 px-1 text-center snap-start transition-all ${
                      isViewing
                        ? 'bg-primary text-primary-foreground shadow-md'
                        : 'bg-white border border-border text-foreground'
                    }`}
                  >
                    <div className={`text-[10px] font-medium ${isViewing ? '' : 'text-muted-foreground'}`}>{dayAbbrev}</div>
                    <div className="text-sm font-bold">{date.getDate()}</div>
                    <div className="flex justify-center gap-0.5 h-1.5">
                      {dayMealCount > 0 ? (
                        [...Array(Math.min(dayMealCount, 4))].map((_, i) => (
                          <div
                            key={i}
                            className={`w-1 h-1 rounded-full ${
                              isViewing ? 'bg-primary-foreground/80' : 'bg-primary'
                            }`}
                          />
                        ))
                      ) : isToday && !isViewing ? (
                        <span className="text-[7px] text-primary font-bold">TODAY</span>
                      ) : null}
                    </div>
                  </button>
                )
              })}
            </div>
          </div>
        </div>

        {/* 3. MAIN CONTENT - Fixed height, no scroll, all 4 meals visible */}
        <div
          ref={mainContentRef}
          className="flex-1 flex flex-col overflow-hidden"
        >
          {/* Date Header - "Monday 8 December" */}
          <div className="px-3 py-1 flex-shrink-0">
            <h2 className="text-sm font-semibold">{formattedSelectedDate}</h2>
          </div>

          {/* Error message */}
          {generationError && (
            <div className="mx-3 mb-1 p-2 bg-red-50 border border-red-200 rounded-lg text-red-700 text-xs flex items-center gap-2 flex-shrink-0">
              <AlertCircle className="h-3 w-3 flex-shrink-0" />
              <span className="flex-1">{generationError}</span>
              <button onClick={() => setGenerationError(null)} className="text-red-500">
                <X className="h-3 w-3" />
              </button>
            </div>
          )}

          {/* Meal Cards - Compact, all 4 visible, NO SCROLL */}
          <div className="flex-1 px-3 pb-1 flex flex-col gap-1.5 overflow-hidden">
            {MEAL_SLOTS.map(slot => {
              const recipe = dayMeals[slot.id]
              const isSwapping = swappingSlot === slot.id

              return (
                <div key={slot.id} className="flex-1 min-h-0">
                  <MealSlotCard
                    key={`${slot.id}-${selectedDateKey}`}
                    slot={slot}
                    recipe={recipe}
                    onSwap={() => setSwappingSlot(isSwapping ? null : slot.id)}
                    onClear={() => handleClearSlot(slot.id)}
                    isSwapping={isSwapping}
                    members={members}
                    isHouseholdMode={isHouseholdMode}
                    compact={true}
                  />
                </div>
              )
            })}
          </div>
        </div>

        {/* Mobile Recipe Picker Sheet - full screen when swapping */}
        {swappingSlot && (
          <RecipePickerSheet
            swappingSlot={swappingSlot}
            dayMeals={dayMeals}
            MEAL_SLOTS={MEAL_SLOTS}
            alternativeSearch={alternativeSearch}
            setAlternativeSearch={setAlternativeSearch}
            filteredAlternatives={filteredAlternatives}
            handleSwapMeal={handleSwapMeal}
            setSwappingSlot={setSwappingSlot}
          />
        )}

        {/* Bottom nav spacer */}
        <div className="h-16 flex-shrink-0" />
      </div>

      {/* ===== DESKTOP LAYOUT ===== */}
      <div className="hidden md:block flex-1 p-6">
        {/* Header */}
        <div className="mb-6">
          <h1 className="text-2xl font-bold">Meal Planner</h1>
          <p className="text-sm text-muted-foreground">
            {weekDateRange ? formatDateRange(weekDateRange.first, weekDateRange.last) : 'This week'}
            {totalWeekMeals > 0 && ` Â· ${totalWeekMeals} meals planned`}
          </p>
        </div>

        {/* Error message */}
        {generationError && (
          <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            {generationError}
            <button onClick={() => setGenerationError(null)} className="ml-auto text-red-500 hover:text-red-700">
              <X className="h-4 w-4" />
            </button>
          </div>
        )}

        {/* Day Strip + Action Buttons */}
        <div className="mb-6 pb-4 border-b space-y-3">
          <div className="flex gap-1.5">
            {allDates.map((date) => {
              const dateKey = toISODate(date)
              const isViewing = isSameDay(date, selectedDate)
              const isToday = isSameDay(date, today)
              const dayMealCount = Object.keys(meals[dateKey] || {}).length
              const dayOfWeek = date.getDay()
              const isWeekend = dayOfWeek === 0 || dayOfWeek === 6
              const dayAbbrev = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek]

              return (
                <button
                  key={dateKey}
                  onClick={() => {
                    setSelectedDate(date)
                    setSwappingSlot(null)
                  }}
                  className={`flex-1 rounded-xl border-2 py-2 px-1 text-center transition-all ${
                    isViewing
                      ? 'bg-primary text-primary-foreground border-primary shadow-md'
                      : isWeekend
                        ? 'bg-muted/60 border-border hover:border-muted-foreground/50'
                        : 'bg-card border-border hover:border-muted-foreground/50'
                  }`}
                >
                  <div className="text-xs font-semibold">{dayAbbrev}</div>
                  <div className="text-base font-bold">{date.getDate()}</div>
                  <div className="flex justify-center gap-0.5 mt-1">
                    {dayMealCount > 0 ? (
                      [...Array(Math.min(dayMealCount, 4))].map((_, i) => (
                        <div key={i} className={`w-1.5 h-1.5 rounded-full ${isViewing ? 'bg-primary-foreground/80' : 'bg-primary'}`} />
                      ))
                    ) : isToday && !isViewing ? (
                      <span className="text-[10px] text-primary font-semibold">Today</span>
                    ) : (
                      <div className="h-1.5" />
                    )}
                  </div>
                </button>
              )
            })}
          </div>

          <div className="flex gap-2">
            <Button size="sm" variant="outline" onClick={() => handleGenerateWeek(false)} disabled={isGenerating || !user} className="h-auto py-2 px-3 text-xs">
              {isGenerating ? <Loader2 className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
              <span className="ml-1.5">Refresh Week</span>
            </Button>
            <Button
              size="sm"
              variant={justCommitted ? "default" : isListStale ? "default" : "outline"}
              onClick={handleCommitToShoppingList}
              disabled={totalWeekMeals === 0}
              className={`h-auto py-2 px-3 text-xs ${justCommitted ? "bg-green-600" : isListStale ? "bg-amber-500" : ""}`}
            >
              {justCommitted ? <><Check className="h-3.5 w-3.5 mr-1" />Added</> : isListStale ? <><AlertCircle className="h-3.5 w-3.5 mr-1" />Update List</> : committedHash ? <><Check className="h-3.5 w-3.5 mr-1" />In List</> : <><ShoppingCart className="h-3.5 w-3.5 mr-1" />Add to List</>}
            </Button>
          </div>
        </div>

        {/* Day Detail */}
        <div>
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">{formatDayHeader(selectedDate)}</h2>
            {Object.keys(dayMeals).length > 0 && (
              <button onClick={handlePrintDayRecipes} className="text-sm text-primary hover:underline flex items-center gap-1">
                <Printer className="h-4 w-4" /> Print Recipes
              </button>
            )}
          </div>

          <div className="space-y-4">
            {MEAL_SLOTS.map(slot => {
              const recipe = dayMeals[slot.id]
              const isSwapping = swappingSlot === slot.id

              return (
                <div key={`${slot.id}-${selectedDateKey}`}>
                  <MealSlotCard
                    slot={slot}
                    recipe={recipe}
                    onSwap={() => setSwappingSlot(isSwapping ? null : slot.id)}
                    onClear={() => handleClearSlot(slot.id)}
                    isSwapping={isSwapping}
                    members={members}
                    isHouseholdMode={isHouseholdMode}
                  />

                  {isSwapping && (
                    <div className="mt-2 p-4 bg-muted/30 rounded-lg border">
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="text-sm font-medium">Choose alternative:</h4>
                        <button onClick={() => setSwappingSlot(null)} className="text-muted-foreground hover:text-foreground">
                          <X className="h-4 w-4" />
                        </button>
                      </div>
                      <div className="mb-3 space-y-2">
                        <input type="text" placeholder="Search recipes..." value={alternativeSearch} onChange={(e) => setAlternativeSearch(e.target.value)} className="w-full px-3 py-1.5 text-sm border rounded-md bg-background" />
                        <div className="flex flex-wrap gap-1">
                          {availableCategories.map(cat => (
                            <button key={cat} onClick={() => setAlternativeCategory(cat)} className={`px-2 py-0.5 text-xs rounded-full border ${alternativeCategory === cat ? 'bg-primary text-primary-foreground border-primary' : 'bg-background hover:bg-muted border-border'}`}>
                              {cat === 'all' ? 'All' : cat.replace('_', ' ')}
                            </button>
                          ))}
                        </div>
                      </div>
                      {filteredAlternatives.length > 0 ? (
                        <div className="grid grid-cols-2 gap-2 max-h-64 overflow-y-auto">
                          {filteredAlternatives.map(alt => (
                            <button key={alt.id} onClick={() => handleSwapMeal(slot.id, alt)} className="text-left p-3 bg-card border rounded-lg hover:border-primary transition-colors">
                              <div className="font-medium text-sm">{alt.name}</div>
                              <div className="text-xs text-muted-foreground mt-1">{alt.per_serve?.calories} cal Â· {alt.total_time_mins} min</div>
                            </button>
                          ))}
                        </div>
                      ) : (
                        <p className="text-sm text-muted-foreground">No alternatives available.</p>
                      )}
                    </div>
                  )}
                </div>
              )
            })}
          </div>

          {Object.keys(dayMeals).length > 0 && !isHouseholdMode && targets && (
            <div className="mt-6 p-4 bg-muted/30 rounded-lg">
              <h3 className="text-sm font-medium text-muted-foreground mb-3">Day Totals</h3>
              <div className="grid grid-cols-4 gap-4">
                <MacroProgress label="Calories" current={dayTotals.calories} target={targets.dailyCalories} />
                <MacroProgress label="Protein" current={dayTotals.protein} target={targets.protein} unit="g" />
                <MacroProgress label="Fat" current={dayTotals.fat} target={targets.fat} unit="g" />
                <MacroProgress label="Carbs" current={dayTotals.carbs} target={targets.carbs} unit="g" />
              </div>
            </div>
          )}
        </div>
      </div>
    </>
  )
}

// Sub-component: Recipe Picker Sheet (mobile full-screen)
function RecipePickerSheet({
  swappingSlot,
  dayMeals,
  MEAL_SLOTS,
  alternativeSearch,
  setAlternativeSearch,
  filteredAlternatives,
  handleSwapMeal,
  setSwappingSlot,
}) {
  const inputRef = useRef(null)
  const hasBlurredOnMount = useRef(false)

  // Blur the input only once on initial mount to prevent auto-focus
  useEffect(() => {
    if (inputRef.current && !hasBlurredOnMount.current) {
      inputRef.current.blur()
      hasBlurredOnMount.current = true
    }
  }, [])

  // Reset the flag when sheet closes (for next time it opens)
  useEffect(() => {
    return () => {
      hasBlurredOnMount.current = false
    }
  }, [])

  return (
    <div
      className="md:hidden fixed inset-0 z-50 bg-card flex flex-col"
      style={{ touchAction: 'none' }}
    >
      {/* Header - fixed at top */}
      <div className="flex-shrink-0 safe-area-top bg-primary text-primary-foreground">
        <div className="flex items-center justify-between px-4 h-14">
          <button
            onClick={() => setSwappingSlot(null)}
            className="p-2 -ml-2 rounded-full active:bg-white/10"
          >
            <X className="h-5 w-5" />
          </button>
          <h3 className="font-semibold text-base">
            {dayMeals[swappingSlot] ? 'Swap' : 'Add'} {MEAL_SLOTS.find(s => s.id === swappingSlot)?.label}
          </h3>
          <div className="w-9" /> {/* Spacer for centering */}
        </div>
      </div>

      {/* Search - fixed below header */}
      <div className="flex-shrink-0 px-4 py-3 border-b bg-card">
        <input
          ref={inputRef}
          type="text"
          inputMode="search"
          enterKeyHint="search"
          autoComplete="off"
          autoCorrect="off"
          autoCapitalize="off"
          spellCheck="false"
          placeholder="Search recipes..."
          value={alternativeSearch}
          onChange={(e) => setAlternativeSearch(e.target.value)}
          className="w-full px-3 py-2.5 text-base border rounded-lg bg-background"
        />
        <p className="text-xs text-muted-foreground mt-2">
          {filteredAlternatives.length} recipes available
        </p>
      </div>

      {/* Recipe list - scrollable, takes remaining space */}
      <div
        className="flex-1 overflow-y-auto px-4 py-2 space-y-2"
        style={{ overscrollBehavior: 'contain' }}
      >
        {filteredAlternatives.length > 0 ? (
          filteredAlternatives.map(alt => (
            <button
              key={alt.id}
              onClick={() => handleSwapMeal(swappingSlot, alt)}
              className="w-full text-left p-3 bg-muted/30 border rounded-lg active:bg-muted transition-colors"
            >
              <div className="font-medium text-sm">{sanitizeText(alt.name)}</div>
              <div className="text-xs text-muted-foreground mt-0.5">
                {alt.per_serve?.calories} cal Â· {alt.per_serve?.protein_g}P Â· {alt.total_time_mins} min
              </div>
              {alt.description && sanitizeText(alt.description) && (
                <div className="text-xs text-muted-foreground/70 mt-1 line-clamp-1">
                  {sanitizeText(alt.description)}
                </div>
              )}
            </button>
          ))
        ) : (
          <div className="text-center py-8 text-muted-foreground">
            <p className="text-sm">No recipes found</p>
            <p className="text-xs mt-1">Try a different search term</p>
          </div>
        )}
      </div>

      {/* Safe area for bottom */}
      <div className="h-4 flex-shrink-0 safe-area-bottom" />
    </div>
  )
}

// Sub-component: Meal slot card
function MealSlotCard({ slot, recipe, onSwap, onClear, isSwapping, members, isHouseholdMode, compact = false }) {
  // ALL HOOKS MUST BE AT THE TOP - before any conditional returns
  const [isOverlayOpen, setIsOverlayOpen] = useState(false)
  const [swipeOffset, setSwipeOffset] = useState(0) // Positive = swipe left (Swap), Negative = swipe right (Recipe)
  const [swipeDirection, setSwipeDirection] = useState(null) // 'left' | 'right' | null
  const [isRevealed, setIsRevealed] = useState(false) // Gmail-style: stays revealed until dismissed
  const [revealedDirection, setRevealedDirection] = useState(null) // Which direction is revealed
  const [isSwiping, setIsSwiping] = useState(false)
  const touchStartX = useRef(0)
  const touchStartY = useRef(0)
  const lastTapTime = useRef(0)
  const isHorizontalSwipe = useRef(false)
  const cardRef = useRef(null)

  // Gmail-style swipe thresholds
  const REVEAL_THRESHOLD = 60  // Swipe this far to reveal button
  const ACTION_THRESHOLD = 140 // Swipe this far to trigger action immediately
  const REVEALED_POSITION = 80 // Where card sits when revealed

  // Calculate household portions for ingredient scaling
  const householdPortions = useMemo(() => {
    if (!isHouseholdMode || !members || members.length === 0 || !recipe) {
      return { total: 1, breakdown: [] }
    }

    const portions = members.map(member => {
      const portion = calculateMemberPortion(member, recipe, slot.id)
      return { name: member.name, portion, isPrimary: member.is_primary }
    })

    const total = portions.reduce((sum, p) => sum + p.portion, 0)

    const breakdown = portions.map(p => ({
      ...p,
      percentage: Math.round((p.portion / total) * 100)
    }))

    return { total, breakdown }
  }, [isHouseholdMode, members, recipe, slot.id])

  // Haptic feedback helper
  const triggerHaptic = useCallback(() => {
    if (typeof navigator !== 'undefined' && navigator.vibrate) {
      navigator.vibrate(10)
    }
  }, [])

  // Reset swipe state
  const resetSwipe = useCallback(() => {
    setSwipeOffset(0)
    setSwipeDirection(null)
    setIsRevealed(false)
    setRevealedDirection(null)
    lastTapTime.current = 0
  }, [])

  // Trigger swap action (swipe left) with haptic
  const triggerSwapAction = useCallback(() => {
    triggerHaptic()
    onSwap()
    resetSwipe()
  }, [onSwap, triggerHaptic, resetSwipe])

  // Trigger recipe action (swipe right) with haptic
  const triggerRecipeAction = useCallback(() => {
    triggerHaptic()
    setIsOverlayOpen(true)
    resetSwipe()
  }, [triggerHaptic, resetSwipe])

  // Handle tap outside to dismiss revealed state
  const handleCardClick = useCallback((e) => {
    if (isRevealed) {
      // If revealed and tapping the card (not the button), dismiss
      resetSwipe()
      return
    }
    // No double-tap anymore - use swipe-right for recipe
  }, [isRevealed, resetSwipe])

  // Swipe handlers - Gmail-style two-stage, bidirectional
  const handleTouchStart = useCallback((e) => {
    touchStartX.current = e.touches[0].clientX
    touchStartY.current = e.touches[0].clientY
    isHorizontalSwipe.current = false
    setIsSwiping(true)
  }, [])

  const handleTouchMove = useCallback((e) => {
    if (!isSwiping) return
    const currentX = e.touches[0].clientX
    const currentY = e.touches[0].clientY
    const diffX = touchStartX.current - currentX // Positive = swipe left, Negative = swipe right
    const diffY = Math.abs(currentY - touchStartY.current)

    // Determine swipe direction on first significant movement
    if (!isHorizontalSwipe.current && (Math.abs(diffX) > 10 || diffY > 10)) {
      isHorizontalSwipe.current = Math.abs(diffX) > diffY
    }

    // Only track horizontal swipe
    if (isHorizontalSwipe.current) {
      // Determine current swipe direction
      const currentDirection = diffX > 0 ? 'left' : 'right'

      // If we're revealed in one direction and swiping the other way, reset first
      if (isRevealed && revealedDirection && currentDirection !== revealedDirection) {
        // Allow swiping back to closed from revealed position
        const baseOffset = revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION
        const newOffset = baseOffset + diffX

        // If swiping back toward center, allow it
        if ((revealedDirection === 'left' && newOffset < REVEALED_POSITION) ||
            (revealedDirection === 'right' && newOffset > -REVEALED_POSITION)) {
          setSwipeOffset(newOffset)
          // Check if we crossed zero - switch directions
          if ((revealedDirection === 'left' && newOffset < 0) ||
              (revealedDirection === 'right' && newOffset > 0)) {
            setSwipeDirection(currentDirection)
          }
          return
        }
      }

      // Normal swipe from neutral or continuing in same direction
      if (!isRevealed) {
        setSwipeDirection(currentDirection)
        // For empty cards, only allow swipe left (no recipe to view)
        if (!recipe && currentDirection === 'right') {
          return
        }
        // Clamp to max swipe distance in either direction
        const clampedOffset = Math.max(-180, Math.min(diffX, 180))
        setSwipeOffset(clampedOffset)
      } else if (revealedDirection === currentDirection) {
        // Continuing in same direction from revealed position
        const baseOffset = revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION
        const newOffset = baseOffset + diffX
        if (revealedDirection === 'left') {
          setSwipeOffset(Math.max(0, Math.min(newOffset, 180)))
        } else {
          setSwipeOffset(Math.min(0, Math.max(newOffset, -180)))
        }
      }
    }
  }, [isSwiping, isRevealed, revealedDirection, recipe])

  const handleTouchEnd = useCallback(() => {
    setIsSwiping(false)
    isHorizontalSwipe.current = false

    const absOffset = Math.abs(swipeOffset)
    const direction = swipeOffset > 0 ? 'left' : 'right'

    // Stage 2: Past action threshold - trigger immediately
    if (absOffset >= ACTION_THRESHOLD) {
      if (direction === 'left') {
        triggerSwapAction()
      } else if (recipe) {
        triggerRecipeAction()
      } else {
        resetSwipe()
      }
      return
    }

    // Stage 1: Past reveal threshold - snap to revealed position
    if (absOffset >= REVEAL_THRESHOLD) {
      // Only reveal recipe button if there's a recipe
      if (direction === 'right' && !recipe) {
        resetSwipe()
        return
      }
      setSwipeOffset(direction === 'left' ? REVEALED_POSITION : -REVEALED_POSITION)
      setIsRevealed(true)
      setRevealedDirection(direction)
      return
    }

    // Below threshold - snap back to closed
    resetSwipe()
  }, [swipeOffset, recipe, triggerSwapAction, triggerRecipeAction, resetSwipe])

  // Handle touch cancel
  const handleTouchCancel = useCallback(() => {
    setIsSwiping(false)
    isHorizontalSwipe.current = false
    // Snap to either revealed or closed based on current state
    if (isRevealed && revealedDirection) {
      setSwipeOffset(revealedDirection === 'left' ? REVEALED_POSITION : -REVEALED_POSITION)
    } else {
      resetSwipe()
    }
  }, [isRevealed, revealedDirection, resetSwipe])

  // Handle rating
  const handleRate = (rating) => {
    console.log('Recipe rated:', rating, recipe.id)
  }

  // Visual states for swipe-left (Swap/Add - green, right side)
  const swipeLeftOffset = Math.max(0, swipeOffset)
  const isNearSwapAction = swipeLeftOffset >= ACTION_THRESHOLD - 20
  const showSwapButton = swipeLeftOffset > 30 || (isRevealed && revealedDirection === 'left')

  // Visual states for swipe-right (Recipe - yellow, left side)
  const swipeRightOffset = Math.abs(Math.min(0, swipeOffset))
  const isNearRecipeAction = swipeRightOffset >= ACTION_THRESHOLD - 20
  const showRecipeButton = swipeRightOffset > 30 || (isRevealed && revealedDirection === 'right')

  // Early return for empty slot - AFTER all hooks
  if (!recipe) {
    // COMPACT MODE (mobile) - swipeable empty card with Gmail-style reveal (only swipe-left for Add)
    if (compact) {
      return (
        <div className="relative overflow-hidden rounded-lg h-full">
          {/* Add button behind the card (right side, green) */}
          <div
            className={`absolute right-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearSwapAction ? 'bg-primary' : 'bg-primary/80'
            }`}
            style={{ width: swipeLeftOffset }}
          >
            {showSwapButton && (
              <button
                onClick={triggerSwapAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-primary-foreground text-sm font-semibold ${
                  isNearSwapAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearSwapAction ? '+ Add' : 'Add'}
                </span>
              </button>
            )}
          </div>

          {/* Main card content - slides based on swipe direction */}
          <div
            ref={cardRef}
            className="bg-card border rounded-lg h-full"
            style={{
              touchAction: 'pan-y',
              transform: `translateX(${-swipeLeftOffset}px)`,
              transition: isSwiping ? 'none' : 'transform 0.2s ease-out',
            }}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onTouchCancel={handleTouchCancel}
            onClick={handleCardClick}
          >
            <div className="p-2 h-full flex flex-col justify-center">
              {/* Line 1: Icon + LUNCH + 12:00 */}
              <div className="flex items-center gap-1 text-[11px] text-muted-foreground">
                <span className="text-sm">{slot.icon}</span>
                <span className="uppercase font-semibold tracking-wide">{slot.label}</span>
                <span className="text-muted-foreground/50">Â·</span>
                <span>{slot.time}</span>
              </div>
              {/* Line 2: Empty state message */}
              <h3 className="text-sm font-medium leading-tight text-muted-foreground/60">
                No meal planned
              </h3>
              {/* Line 3: Hint */}
              <p className="text-[11px] text-muted-foreground/40 leading-tight">
                {isRevealed ? 'Tap Add or swipe more' : 'Swipe left to add'}
              </p>
            </div>
          </div>
        </div>
      )
    }

    // DESKTOP MODE - simple empty state
    return (
      <div className="border border-dashed rounded-lg flex items-center justify-between p-4">
        <div className="flex items-center gap-2 text-muted-foreground">
          <span className="text-xl">{slot.icon}</span>
          <span className="text-base">{slot.label}</span>
          <span className="text-xs text-muted-foreground/60">Â· {slot.time}</span>
        </div>
        <Button variant="ghost" size="sm" onClick={onSwap}>
          Add
        </Button>
      </div>
    )
  }

  const macros = recipe.per_serve || {}

  // COMPACT MODE (mobile) - compact card with bidirectional Gmail-style swipe
  // Swipe left â†’ Swap (green), Swipe right â†’ Recipe (yellow)
  if (compact) {
    // Calculate card transform based on bidirectional swipe
    const cardTransform = swipeOffset > 0
      ? -swipeLeftOffset  // Swiping left - card moves left
      : swipeRightOffset  // Swiping right - card moves right

    return (
      <>
        <div className="relative overflow-hidden rounded-lg h-full">
          {/* Recipe button behind the card (LEFT side, yellow) - swipe right reveals */}
          <div
            className={`absolute left-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearRecipeAction ? 'bg-amber-500' : 'bg-amber-400'
            }`}
            style={{ width: swipeRightOffset }}
          >
            {showRecipeButton && (
              <button
                onClick={triggerRecipeAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-white text-sm font-semibold flex items-center gap-1 ${
                  isNearRecipeAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearRecipeAction ? 'ðŸ“– View' : 'Recipe'}
                </span>
              </button>
            )}
          </div>

          {/* Swap button behind the card (RIGHT side, green) - swipe left reveals */}
          <div
            className={`absolute right-0 top-0 bottom-0 flex items-center justify-center transition-colors ${
              isNearSwapAction ? 'bg-primary' : 'bg-primary/80'
            }`}
            style={{ width: swipeLeftOffset }}
          >
            {showSwapButton && (
              <button
                onClick={triggerSwapAction}
                className="w-full h-full flex items-center justify-center"
              >
                <span className={`text-primary-foreground text-sm font-semibold ${
                  isNearSwapAction ? 'scale-110' : ''
                } transition-transform`}>
                  {isNearSwapAction ? 'â†» Swap' : 'Swap'}
                </span>
              </button>
            )}
          </div>

          {/* Main card content - slides based on swipe direction */}
          <div
            ref={cardRef}
            className={`bg-card border rounded-lg h-full ${isSwapping ? 'border-primary border-2' : ''}`}
            style={{
              touchAction: 'pan-y',
              transform: `translateX(${cardTransform}px)`,
              transition: isSwiping ? 'none' : 'transform 0.2s ease-out',
            }}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onTouchCancel={handleTouchCancel}
            onClick={handleCardClick}
          >
            <div className="p-2 h-full flex flex-col justify-center">
              {/* Line 1: Icon + LUNCH + 12:00 + 10 min */}
              <div className="flex items-center gap-1 text-[11px] text-muted-foreground">
                <span className="text-sm">{slot.icon}</span>
                <span className="uppercase font-semibold tracking-wide">{slot.label}</span>
                <span className="text-muted-foreground/50">Â·</span>
                <span>{slot.time}</span>
                {recipe.total_time_mins && (
                  <>
                    <span className="text-muted-foreground/50">Â·</span>
                    <span>{recipe.total_time_mins}m</span>
                  </>
                )}
              </div>
              {/* Line 2: Meal title */}
              <h3 className="text-sm font-medium leading-tight line-clamp-1">
                {sanitizeText(recipe.name)}
              </h3>
              {/* Line 3: Description (single line with ellipsis) */}
              {recipe.description && sanitizeDescription(recipe.description) && (
                <p className="text-[11px] text-muted-foreground leading-tight line-clamp-1">
                  {sanitizeDescription(recipe.description)}
                </p>
              )}
            </div>
          </div>
        </div>

        {/* Full-screen recipe overlay */}
        <RecipeOverlay
          recipe={recipe}
          slot={slot}
          isOpen={isOverlayOpen}
          onClose={() => setIsOverlayOpen(false)}
          onRate={handleRate}
          householdPortions={householdPortions}
          isHouseholdMode={isHouseholdMode}
          onSwap={onSwap}
          onClear={onClear}
        />
      </>
    )
  }

  // FULL MODE (desktop)
  return (
    <>
      <div className={`relative border rounded-xl overflow-hidden ${isSwapping ? 'border-primary border-2' : ''}`}>
        {/* Main card content */}
        <div className="relative bg-card">
          <div className="p-4">
            {/* Meal type / time row */}
            <div className="flex items-center gap-2 text-xs text-muted-foreground mb-1.5">
              <span className="text-base">{slot.icon}</span>
              <span className="uppercase tracking-wide font-medium">{slot.label}</span>
              <span className="text-muted-foreground/50">â€¢</span>
              <span>{slot.time}</span>
              {recipe.total_time_mins && (
                <span className="flex items-center gap-1 ml-auto">
                  <Clock className="h-3.5 w-3.5" />
                  {recipe.total_time_mins} min
                </span>
              )}
            </div>

            {/* Recipe title */}
            <h3 className="text-base font-medium leading-tight">
              {sanitizeText(recipe.name)}
            </h3>

            {/* Description */}
            {recipe.description && sanitizeDescription(recipe.description) && (
              <p className="text-sm text-muted-foreground mt-1 leading-relaxed">
                {sanitizeDescription(recipe.description)}
              </p>
            )}

            {/* Macros */}
            <div className="flex gap-3 mt-2 text-xs text-muted-foreground">
              <span>{macros.calories} cal</span>
              <span>{macros.protein_g}P</span>
              <span>{macros.fat_g}F</span>
              <span>{macros.carbs_g}C</span>
            </div>
          </div>

          {/* Action buttons */}
          <div className="flex items-center gap-3 px-4 py-2 bg-muted/20 border-t">
            <button
              onClick={() => setIsOverlayOpen(true)}
              className="text-sm text-primary hover:underline"
            >
              View recipe
            </button>
            <span className="text-muted-foreground/30">|</span>
            <button
              onClick={onSwap}
              className={`text-sm hover:underline ${isSwapping ? 'text-primary font-medium' : 'text-muted-foreground'}`}
            >
              <RefreshCw className="h-3 w-3 inline mr-1" />
              Swap
            </button>
            <button
              onClick={onClear}
              className="text-sm text-muted-foreground hover:text-destructive hover:underline"
            >
              Remove
            </button>
          </div>
        </div>
      </div>

      {/* Full-screen recipe overlay */}
      <RecipeOverlay
        recipe={recipe}
        slot={slot}
        isOpen={isOverlayOpen}
        onClose={() => setIsOverlayOpen(false)}
        onRate={handleRate}
        householdPortions={householdPortions}
        isHouseholdMode={isHouseholdMode}
      />
    </>
  )
}

// Sub-component: Macro progress bar
function MacroProgress({ label, current, target, unit = '' }) {
  const percentage = target > 0 ? Math.min((current / target) * 100, 100) : 0
  const isOver = current > target
  
  return (
    <div>
      <div className="flex justify-between text-sm mb-1">
        <span className="text-muted-foreground">{label}</span>
        <span className={isOver ? 'text-amber-600 font-medium' : ''}>
          {Math.round(current)}{unit} / {target}{unit}
        </span>
      </div>
      <div className="h-2 bg-muted rounded-full overflow-hidden">
        <div 
          className={`h-full transition-all ${isOver ? 'bg-amber-500' : 'bg-primary'}`}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  )
}
